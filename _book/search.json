[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Physiological Blueprint",
    "section": "",
    "text": "Welcome\nTo the dedicated kinesiologist, exercise physiologist, researcher, and student embarking on the fascinating journey of understanding the human body: Welcome.\nYou live and breathe the complexity of physiological systems. You measure dynamic responses to stimuli like exercise, gravitational changes, or stress. You investigate intricate regulatory mechanisms, from the molecular dance within a muscle fiber to the integrated control exerted by the nervous and endocrine systems. You understand that the body is not a static machine but a vibrant, ever-changing network of interacting processes.\nYet, precisely because of this inherent complexity and dynamism, some of the most profound questions in physiology remain challenging to answer. We can measure what happens – heart rate increases, oxygen consumption rises, hormone levels fluctuate. But fully understanding how and why these variables change together over time, how different feedback loops compete or cooperate, and what the quantitative impact of altering a specific component might be, often requires looking beyond traditional experimental and statistical approaches alone.\nThis book offers you a powerful additional lens through which to explore these questions: mathematical modeling, specifically using ordinary differential equations (ODEs) as the language and the R programming environment as the essential workbench.\nI understand that for many in the life sciences, terms like “differential equations” might conjure images of abstract mathematical theory or intimidating calculus exams. Likewise, sticking your head into computer programming might seem like a detour from your core research interests. This book is written precisely to bridge that gap.\nMy goal is not to turn you into a theoretical mathematician or a computer science expert, but to empower you to use mathematical modeling as a practical, intuitive, and insightful tool for your physiological research. I believe that the fundamental concepts of dynamic modeling with ODEs are inherently physiological, reflecting the rates of change and interactions you already study. I also believe that modern computational tools like R make this approach accessible, allowing you to focus on the biology while leveraging the computer for the heavy lifting of simulation and visualization.\nThis book is structured to guide you step-by-step, assuming no prior knowledge of differential equations or R programming. We will start by building a strong intuitive understanding of why dynamic modeling is valuable for physiology (Chapter 1). You will then be gently introduced to the essential R skills you need (Chapter 2) and the core concept of rates of change that underpins differential equations (Chapter 3). We will then show you how to translate simple physiological ideas into the language of ODEs (Chapter 4).\nWith these foundations in place, Part 2 will equip you with the practical skills to solve, simulate, and visualize ODE models using powerful R packages like deSolve and ggplot2. You will learn how to bring your physiological blueprints to life on the computer and see the dynamic behavior they predict.\nPart 3 is where we dive into applying these tools to specific physiological systems, progressively building models of cardiovascular dynamics, autonomic control, and exercise responses. Throughout these chapters, we will use a consistent case study focusing on the dynamic control of heart rate during exercise and recovery – a topic central to cardiac autonomic modulation research – to demonstrate how to construct and analyze models that can address real research questions in your field. You will see how to integrate different physiological components into coupled systems of equations and interpret the results in a biologically meaningful way.\nFinally, Part 4 will explore slightly more advanced concepts and discuss the exciting future directions for using dynamic modeling in physiological research, including briefly touching on linking models to experimental data.\nThe approach throughout this book will be practical and physiology-driven. We will minimize abstract mathematical proofs, focusing instead on the biological interpretation of the equations and the insights gained from simulating model behavior. Visualization is key; we will emphasize how plotting your model’s output in R is essential for understanding the dynamics and comparing them to what you observe in the lab or clinic.\nI am confident that by the end of this book, you will not only understand the principles of physiological modeling with ODEs but will also possess the practical skills in R to begin building, exploring, and visualizing your own dynamic models. You will be equipped to ask and answer new types of questions about the “Physiological Blueprint”, adding a powerful dimension to your research capabilities.\nSo get ready to embark on this journey and discover the immense potential of mathematical modeling to deepen your understanding of the complex, dynamic, and beautiful systems you study.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "dedication.html",
    "href": "dedication.html",
    "title": "Dedication",
    "section": "",
    "text": "To my family and friends, whose unwavering support, patience, and belief in me provided the foundation for this work.\nTo my colleagues and mentors, whose way to view the world and ask questions, shared passion for scientific discovery, and collaborative spirit continue to inspire my research and shape my understanding of the physiological world.",
    "crumbs": [
      "Dedication"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "I remember the first time I saw a real-time heart rate trace on a monitor. To most, it’s just a jagged green line, a nervous twitch of light. But if you stare at it long enough, you realize you aren’t just looking at data; you’re looking at a performance. You’re watching the dance of the nerves, the sympathetic and parasympathetic systems locked in a constant, elegant dance to maintain the balance we call life.\nI wrote this book because I spent years frustrated by the way we teach physiology. Usually, it’s a list of parts to memorize. Then, we go to math class, and it’s a list of formulas to apply. But the body doesn’t exist in a vacuum, and math isn’t just a hurdle to clear.\nThe Physiological Blueprint is about the intersection of the two. It’s about understanding the architecture of life through the lens of movement. We aren’t interested in static snapshots; we want to know how things change. Why does a runner’s heart rate settle at 150 beats per minute? Why does a drug clear the blood in hours rather than seconds?\nTo answer these, we need a language that speaks in “rates of change”. That language is Ordinary Differential Equations (ODEs).\n\nWhy R? Why Now?\nYou might wonder why we’re using R. Some see it as a tool for “just statistics”, but I see it as a high-fidelity lens. With modern packages we can take an abstract idea and turn it into a living simulation in a few lines of code. We are living in a golden age where the barrier between a biological hypothesis and a digital model is thinner than it’s ever been.\n\n\nHow to Use This Book\nThis isn’t a “Definition-Theorem-Proof” textbook. We aren’t here to grind through manual integrations that a computer can do in a millisecond. Instead, we are going to focus on:\n\nIntuition: What is the biology actually doing?\nImplementation: How do we translate that “doing” into R code?\nInterpretation: What does the model tell us about the ghost in the machine, those emergent properties of life that aren’t obvious until you see the system in motion?\n\nWe’ll start with the basics of R, move through the mechanics of differential equations, and eventually build complex models of cardiovascular flow and autonomic control.\n\n\nA Note to the Reader\nBiology is messy. It’s loud, it’s stochastic, and it’s gloriously complicated. A model will never be a perfect representation of a human being, and that’s okay. As the saying goes, “All models are wrong, but some are useful”. Our goal is to build models that are useful enough to help us see the blueprint underneath the skin.\nGrab a cup of coffee, fire up RStudio, and let’s get started. The architecture is waiting.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01-why-model-physiology.html",
    "href": "01-why-model-physiology.html",
    "title": "1  Why Model Physiology?",
    "section": "",
    "text": "1.1 The Power of Mathematical Modeling in Biological Systems\nI remember the first time I saw a model “breathe”. I was sitting in the lab, staring at a jagged heart rate trace that made no sense. I wrote three lines of R code, pressed ‘Run’, and suddenly, a line in the plot cut through the noise with perfect, mathematical grace. It was like the ghost in the machine finally whispered its name to me. I wasn’t just looking at data anymore; I was looking at the blueprint of a human being.\nI want you to take a second and think about the last time you went for a run or watched someone finish a sprint.\nTo the casual observer, it’s just movement, sweat, heavy breathing, and a look of sheer determination. But to us, it’s a symphony. Beneath the skin, there is a frantic, beautiful coordination happening. The lungs are expanding to capture oxygen; the heart is racing to distribute that oxygen to hungry muscles; the brain is firing signals to maintain balance and temperature. This is the architecture of life in its most active state.\nBut here’s the problem: if we only look at the runner from the outside, we only see the outputs. We see the heart rate on a smartwatch or the pace on a track. We don’t see the “why”. We don’t see the invisible gears, the feedback loops and the chemical signals, that make that performance possible. This is where we encounter the ghost in the machine. There is a logic to the chaos of biology, a set of rules that governs how our bodies react to the world.\nMathematical modeling is the process of sketching the blueprint of that ghost. It is the tool that allows us to move from being mere spectators of life to being architects of understanding.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Model Physiology?</span>"
    ]
  },
  {
    "objectID": "01-why-model-physiology.html#the-power-of-mathematical-modeling-in-biological-systems",
    "href": "01-why-model-physiology.html#the-power-of-mathematical-modeling-in-biological-systems",
    "title": "1  Why Model Physiology?",
    "section": "",
    "text": "1.1.1 Beyond the Spreadsheet: The Living System\nIn traditional physiology, we are often taught to think in snapshots. We learn that a resting heart rate is “X” and an exercising heart rate is “Y”. We look at tables, mean values, and standard deviations. This is useful, sure, but it’s static. It’s like trying to understand a movie by looking at a single frame.\nThe human body is never static. It is a dynamic, breathing, shifting entity. Every second, your physiological state is a result of what happened a millisecond ago and a predictor of what will happen a millisecond from now. This is the dance of life, the constant, elegant tug-of-war between the sympathetic “fight or flight” system and the parasympathetic “rest and digest” system.\nWhen we model these systems, we stop looking at the “snapshots” and start looking at the “motion”. A mathematical model is, at its heart, a story told in the language of logic. It describes how one thing changes in response to another. Instead of saying “the heart rate increased”, a model allows us to say “the heart rate increased because the sympathetic drive overcame the vagal tone at a specific rate, influenced by the rising concentration of circulating catecholamines”.\nBy using math, we aren’t making biology colder or more abstract; we are actually getting closer to the truth of its complexity.\n\n\n1.1.2 The Power of Simplification (The Map and the Territory)\nThere’s a famous trap that new modelers often fall into: they try to include everything. They want to model every single capillary, every individual neuron, and every molecular interaction. But a model that is as complex as the human body is just as difficult to understand as the human body itself.\nThink of a map. If a map of a city were life-sized and contained every blade of grass and every pebble on the street, it wouldn’t be a map, it would just be the city. To be useful, a map must be a simplification. It must highlight the roads and the landmarks while ignoring the clutter.\nThis is the true power of mathematical modeling in physiology. It forces us to ask: What actually matters? When we sit down at our keyboards and start writing R code to simulate a cardiovascular system, we are making decisions about the “architecture of life”. We are deciding which variables are the pillars of the system and which are just the decorative molding. By stripping away the noise, we reveal the underlying mechanisms. If our simplified model can still predict how a heart reacts to a sudden sprint, then we know we’ve captured the essence of the system. We’ve found the blueprint.\n\n\n1.1.3 Seeing the Unseen: Emergent Properties\nOne of the most mind-blowing aspects of biological modeling is something called emergence.\nThe body is a “system of systems”. Your heart is a pump, but it’s governed by your nervous system, which is influenced by your blood chemistry, which is regulated by your kidneys and lungs. Individually, these components are fascinating. But when you link them together in a model, something magical happens: the system starts to exhibit behaviors that none of the individual parts possess.\nConsider Heart Rate Variability (HRV). If you look at a heart muscle cell in a petri dish, it just pulses. If you look at a single nerve, it just fires. But when you model the interaction between the heart and the autonomic nervous system, you suddenly see these complex, fractal-like rhythms emerge in the heart rate, rhythms that indicate health, stress, and resilience.\nWe call this “the ghost in the machine” because the behavior arises from the interaction of the parts, not the parts themselves. Without modeling, these emergent properties often seem like magic or random noise. With a model, we can trace the lines of logic and see exactly how the “dance of the nerves” creates the rhythm of the heart.\n\n\n1.1.4 Why This Book, and Why Now?\nI’m 26. I grew up in a world where data is everywhere. We have sensors on our wrists, rings on our fingers, and apps that track our sleep, our steps, and our strain. We are drowning in physiological data. But data without a model is just a pile of bricks.\nIn the past, modeling was reserved for the “math people”, the ones who spent their days in dusty offices writing Greek symbols on chalkboards. But the world has changed. We have R.\nR is more than just a statistical language; it’s a laboratory. With modern packages, we can build a world, set the rules of physics (or physiology), and press “play”. We can simulate a patient with heart failure, an athlete at high altitude, or a person experiencing a panic attack, all within a few lines of code.\nI’m writing this because I want to give you the keys to that laboratory. I want you to feel the same rush I feel when a model I’ve built starts to “breathe” on the screen. When the lines on the graph start to mimic the data we see in the real world, it’s an incredible feeling. It’s the moment you realize you’ve understood a piece of the architecture.\n\n\n1.1.5 The Path Ahead\nIn this book, we aren’t going to get bogged down in dry, abstract proofs. I’m not going to ask you to solve a hundred equations by hand. That’s what the computer is for. Instead, we are going to focus on the logic.\nWe will learn how to:\n\nIdentify the variables: What are the moving parts? (The “state variables”).\nDefine the relationships: How does one part push or pull another? (The “rates of change”).\nSimulate the system: Using R to bring the equations to life.\nListen to the model: What is the model telling us about the biology?\n\nWhether you are a student of kinesiology, a medical researcher, or just a data nerd who is fascinated by the human body, modeling will change the way you see the world. You will stop seeing “averages” and start seeing “dynamics”. You will stop seeing “bodies” and start seeing “blueprints”.\nThe architecture of life is complex, yes. It is messy and loud and sometimes confusing. But it is not random. It follows a dance, a beautiful, mathematical dance.\n\n\n\n\n\n\nThe Feedback Loop\n\n\n\nAt the core of almost every model we will build is the concept of homeostasis. The body doesn’t just “change”; it reacts to change to keep things stable. This is a feedback loop. Think of your thermostat at home:\n\nSensor: Measures the temperature.\nController: Decides if it’s too cold.\nEffector: Turns on the heater.\n\nIn physiology, the “heater” might be your heart rate, and the “sensor” might be the baroreceptors in your neck. Modeling allows us to see how these loops prevent the system from spiraling out of control.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Model Physiology?</span>"
    ]
  },
  {
    "objectID": "01-why-model-physiology.html#the-role-of-models-in-hypothesis-generation-and-testing",
    "href": "01-why-model-physiology.html#the-role-of-models-in-hypothesis-generation-and-testing",
    "title": "1  Why Model Physiology?",
    "section": "1.2 The Role of Models in Hypothesis Generation and Testing",
    "text": "1.2 The Role of Models in Hypothesis Generation and Testing\nI want you to imagine you’re standing in a high-performance physiology lab. It’s expensive, it’s clinical, and it’s filled with the hum of digital devices and the beeping of measurement equipment. You have a question, a “what if”. You wonder: What if we could selectively dampen the parasympathetic “brake” on the heart during the first ten seconds of exercise without affecting the sympathetic “gas pedal”? In the physical world, answering that is a nightmare. You’d need ethical clearances, a cohort of incredibly patient volunteers, and perhaps some very invasive (and likely impossible) pharmacological interventions. I’ve spent those months. I’ve lived in that hum. And trust me, while there’s a certain romance to the physical lab, there’s an unmatched power in being able to test a theory while the coffee in your mug is still hot. We’re moving the frontier of discovery from the treadmill to the silicon. By the time you’ve set up the experiment, months have passed, and you’ve spent thousands of dollars just to test one tiny branch of the autonomic nervous system.\nBut what if you didn’t have to start with the treadmill? What if you had a “virtual runner” living inside your laptop?\nThis is where the true power of modeling reveals itself. In this section, we’re going to talk about how models aren’t just pretty pictures or summaries of what we already know. They are hypothesis machines. They are the tools we use to explore the “what-ifs” of biology before we ever draw a drop of blood.\n\n1.2.1 The “What-If” Machine: Generating New Ideas\nMost people think science starts with an experiment. I’d argue that, in the modern age, it starts with a simulation.\nWhen we build a model of a physiological system, say, the way the baroreflex regulates blood pressure, we are essentially writing down a formal hypothesis. Every equation we write is a claim: “I believe this variable influences that one in this specific way”.\nOnce that model is coded in R, it becomes a sandbox. You can start “tweaking” the parameters. You can turn the sympathetic gain up to 11. You can simulate a heart that has lost its elastic compliance. You can create a “ghost” of a person who doesn’t exist in the real world.\nAs you play with these virtual knobs, the model will often spit out behaviors you didn’t expect. You might find that at a certain intensity of exercise, the heart rate doesn’t just plateau; it starts to oscillate. That’s a “What-If” moment. You didn’t program that oscillation specifically; it emerged from the rules of the system.\nSuddenly, you have a new hypothesis: Does heart rate stability break down at near-maximal intensities due to a lag in autonomic feedback? You didn’t find this by looking at old textbooks. You found it by exploring the logic of your model. This is hypothesis generation. The model has pointed its finger toward a corner of the physiology that you hadn’t considered looking at before.\n\n\n1.2.2 The In Silico Laboratory: Testing without the Treadmill\nOnce you have a hypothesis, the model becomes your first line of testing. We call this in silico testing (literally “in silicon”, referring to the computer chips).\nTesting a hypothesis in a model is like a flight simulator for a pilot. You wouldn’t put a trainee in a Boeing 747 and tell them to “see what happens” if an engine fails over the Atlantic. You put them in a simulator. Similarly, we can use our models to see if our biological theories even hold water mathematically.\nSuppose you have a theory about why some athletes experience a “second wind”. You think it’s related to a specific delay in oxygen kinetics. You build the model, plug in the numbers, and run the simulation. If the model’s output looks nothing like a “second wind”, you’ve just saved yourself six months of lab work. Your hypothesis, in its current form, is mathematically impossible. If the model does show a second wind, you’ve just gained a massive amount of confidence. You now have a “proof of concept” that your logic is sound.\nThis “fail fast” mentality is common in the tech world, and it’s exactly how we should be approaching this dance. Why waste resources on an experiment that can’t even work in theory?\n\n\n1.2.3 Falsifiability and the “Wrong” Model\nHere is a bit of mentor-to-mentee philosophy: It is a good thing when your model is wrong.\nIn science, we talk a lot about “falsifiability”. A theory is only useful if there is a way to prove it’s incorrect. If I tell you that “the heart beats because of a magical spirit”, I haven’t given you a scientific theory, because there’s no way to test the spirit’s absence.\nBut if I give you a model that predicts a heart rate of 120 bpm under stress, and your real-world data shows 160 bpm, we have a beautiful, productive conflict. The model’s failure tells us exactly where our understanding of the architecture of the system is flawed. Is the sympathetic gain too low in our code? Did we forget a feedback loop? Is there a “ghost” in the real machine (a hidden variable) that we haven’t accounted for?\nWhen the model doesn’t match the data, it’s not a “mistake”. It’s a map to a new discovery. Every time we refine the R code to better match the real-world heart rate trace, we are refining our understanding of life itself.\n\n\n1.2.4 Case in Point: Autonomic Modulation\nAs we move through this book, we will focus heavily on how the brain talks to the heart. This “dance” is the perfect playground for hypothesis testing.\nFor instance, there is a long-standing debate about how much the “sympathetic” and “parasympathetic” branches actually interact. Are they purely additive (one goes up, the other goes down), or is there “accentuated antagonism” where one branch actively interferes with the other?\nBy the time you finish Part 2 of this book, you’ll be able to build two versions of a model: one where the branches are independent and one where they interact. You can run them both, compare them to a real R-R interval trace, and see which one “fits” better. In one afternoon, you can contribute to a debate that has lasted decades.\nThat is the power you have at your fingertips. We’re learning to think in dynamics. We’re learning to listen to the machine so we can understand the ghost.\n\n\n\n\n\n\nThe Virtual Knockout\n\n\n\nIn genetics, a “knockout” is an organism engineered to lack a specific gene to see what happens. In modeling, we perform “virtual knockouts”. We can set a specific parameter (like the rate of acetylcholine release) to exactly zero. This allows us to observe a “pure” sympathetic system, something that is almost impossible to achieve in a living, breathing human without causing a medical emergency.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Model Physiology?</span>"
    ]
  },
  {
    "objectID": "01-why-model-physiology.html#why-differential-equations-are-a-natural-language-for-physiology",
    "href": "01-why-model-physiology.html#why-differential-equations-are-a-natural-language-for-physiology",
    "title": "1  Why Model Physiology?",
    "section": "1.3 Why Differential Equations are a Natural Language for Physiology",
    "text": "1.3 Why Differential Equations are a Natural Language for Physiology\nIf you want to understand the architecture of life and biological systems, you have to stop thinking about what the body is and start thinking about what the body does.\nMost of our educational lives, we are taught to categorize. We learn the names of the bones, the regions of the brain, and the layers of the heart. This is the study of “being”. But physiology is the study of “becoming”. Nothing in your body is truly still. Even as you sit here reading this, your blood is a river in constant motion, your neurotransmitters are crossing synapses in a frantic relay race, and your cells are burning fuel at a rate that shifts with every breath.\nThe problem with standard language, the kind we use to talk about our day or write a grocery list, is that it’s terrible at describing things that are constantly changing in relation to one another. If I say, “my heart rate is high”, I’m giving you a static data point. But if I want to describe the dance of the autonomic nervous system, how the heart rate climbs as the vagal tone withdraws and the sympathetic drive kicks in, I need a language that can handle the “flux”.\nThat language is the Differential Equation.\nDon’t let the word ‘Equation’ scare you off. We aren’t here to do math for the sake of math; we’re here to give the ghost a voice. In our world, an equation is just a sentence that refuses to be static.\n\n1.3.1 The Speedometer of the Soul\nI like to think of Ordinary Differential Equations (ODEs) as the “speedometers” of the biological world.\nThink about driving a car. You have two main pieces of information: where you are (your position) and how fast you’re going (your velocity). In physiology, the “where you are” is your current state, your current blood glucose level, your current heart rate, or the current concentration of lactate in your muscles. The “how fast you’re going” is the rate of change.\nAn ODE is simply a mathematical sentence that links the two. It says: “The rate at which this thing changes depends on the state it’s currently in (and perhaps some outside forces)”.\nIn a spreadsheet, you might see data points at minute 1, minute 2, and minute 3. But the body doesn’t live in minute-long chunks. It lives in the infinitesimal gaps between those minutes. Differential equations allow us to peer into those gaps. They treat time not as a series of steps, but as a smooth, continuous flow. This is why they feel so “natural” when applied to biology; they respect the continuity of life.\n\n\n1.3.2 The Logic of the Feedback Loop\nThe most profound reason ODEs are the natural language of physiology is that they are built for feedback. As we discussed earlier, the ghost in the machine is usually a feedback loop.\nLet’s look at a classic example: the regulation of blood sugar. When you eat a donut, your blood glucose (\\(G\\)) rises. This rise in glucose triggers your pancreas to release insulin (\\(I\\)). The insulin then acts like a key, opening up your cells to pull the glucose out of the bloodstream, which causes the glucose level to drop.\nIf we were to write this in prose, it’s a bit clunky. If we were to put it in a table, it’s a series of “if-then” statements. But in the language of ODEs, it becomes a beautiful, symmetrical system:\n\nThe rate of change of Glucose (\\(\\frac{dG}{dt}\\)) is decreased by the amount of Insulin (\\(I\\)).\nThe rate of change of Insulin (\\(\\frac{dI}{dt}\\)) is increased by the amount of Glucose (\\(G\\)).\n\nThis is the “blueprint” of a homeostatic system. The equations don’t just tell us what the levels are; they tell us how the levels interact. They describe a relationship where the “speed” of the response is proportional to the “size” of the problem. This is exactly how your body operates. It doesn’t just turn a switch on or off; it modulates. It’s a dimmer switch, not a toggle, and ODEs are the only way to describe that dimming effect accurately.\n\n\n1.3.3 The “Ghost” in the Differential\nOne of my favorite things about ODEs is that they reveal the “hidden” forces in a system. In a simple equation like \\(\\frac{dx}{dt} = kx\\), the “x” is the part we can see (the state), but the “k” is the architecture. That \\(k\\) represents the properties of the tissue, the sensitivity of the receptors, or the efficiency of the enzymes.\nWhen we try to model latent behavior like the autonomic nervous system’s influence on the heart, we aren’t just plotting a line; we are trying to find the value of those hidden parameters.\nTake the heart rate response at the onset of exercise. If you stand up and start sprinting, your heart rate doesn’t instantly jump from 60 to 160. It follows a curve. That curve is defined by a differential equation. The “steepness” of that curve, how fast you reach your steady state, tells us something profound about your autonomic health. A “fast” heart rate response suggests a nimble, responsive nervous system. A “sluggish” response might suggest fatigue or overtraining.\nBy using ODEs, we move beyond asking “What is the heart rate?” and start asking “How responsive is the system?” We are measuring the vitality of the ghost, not just the dimensions of the machine.\n\n\n1.3.4 Continuity in a Discrete World\nWe live in a digital age. We’re used to pixels, frames per second, and discrete “bits” of information. Because of this, it’s tempting to think of physiology as a series of discrete events: a heartbeat, a breath, a muscle twitch.\nBut biology is fundamentally continuous. The transition from rest to exercise is a slide, not a jump. The fading of a drug’s effect in the liver is a slow taper, not a sudden disappearance.\nWhen we use R to solve these equations (which we’ll start doing in Chapter 5), the computer actually has to work quite hard to mimic this continuity. It takes tiny, tiny steps to approximate the smooth flow of the real world. But the logic we provide the computer, the ODE, is continuous. It assumes that for every billionth of a second, there is a corresponding billionth of a change.\nThis is why ODEs are so much more powerful than simple linear regression or static statistics. Statistics looks at the “what happened”. ODEs look at the “how it happens”. They allow us to simulate the process of living.\n\n\n1.3.5 Embracing the Complexity\nI know that for many, the word “equation” brings up memories of dry classrooms and confusing symbols. But I want you to look at these equations as a form of poetry. A differential equation is a way of saying, “the future of this system is contained within its present”.\nIn the chapters to come, we are going to look at the architecture of dynamics through these equations. We’ll see how:\n\nPressure and Flow in your arteries are locked in a differential embrace.\nOxygen Uptake in your lungs follows a predictable rate of change.\nAutonomic Balance is a system of coupled equations where the sympathetic and parasympathetic nerves are constantly trying to find a moving equilibrium.\n\nWe aren’t doing math for the sake of math. We are doing it because we want to speak the body’s native tongue. We want to understand why the heart dances the way it does, and why the ghost in the machine sometimes loses its rhythm.\nSo, don’t fear the \\(\\frac{dy}{dt}\\). See it for what it is: a tiny, mathematical heartbeat. It is the pulse of the model, and it’s what’s going to allow us to build simulations that don’t just look like life, but behave like it.\n\n\n\n\n\n\nODEs vs. Machine Learning\n\n\n\nYou’ll hear a lot of buzz today about “Black Box” AI and Machine Learning. Those tools are great for predicting what will happen based on massive amounts of data. But they don’t tell you how. An ODE model is “White Box”. It’s transparent. Every term in your R code corresponds to a physical reality, a valve, a nerve, a chemical gradient. If you want to truly understand physiology, you don’t want a black box; you want a blueprint.\n\n\nNow that we have the language, let’s look at the poems already written by the giants of our field.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Model Physiology?</span>"
    ]
  },
  {
    "objectID": "01-why-model-physiology.html#examples-of-classic-physiological-models",
    "href": "01-why-model-physiology.html#examples-of-classic-physiological-models",
    "title": "1  Why Model Physiology?",
    "section": "1.4 Examples of Classic Physiological Models",
    "text": "1.4 Examples of Classic Physiological Models\nBefore we start building our own complex architectures in R, we need to pay our respects to the giants whose shoulders we’re standing on. You see, the architecture of life isn’t a new discovery. For decades, brilliant minds have been trying to capture the ghost in the machine using nothing but pen, paper, and the logic of differential equations.\nIn this section, we’re going to walk through a few “Greatest Hits”. These aren’t just dry historical artifacts; they are the foundational blueprints for almost everything we do in modern modeling. Whether you’re tracking a virus through a population or a drug through a kidney, the underlying math often traces back to these classic forms.\n\n1.4.1 The Simplest Blueprint: Exponential Growth and Decay\nThe most fundamental “movement” in biology is the change that depends directly on the current state. Imagine a colony of bacteria in a petri dish with infinite snacks. The more bacteria there are, the more they reproduce. The rate of change is proportional to the population size.\nMathematically, we write this as:\n\\[\\frac{dN}{dt} = rN\\]\nHere, \\(N\\) is the number of bacteria, and \\(r\\) is the growth rate. This is the “Pure Growth” model. It’s the simplest way to describe a system that is running away with itself.\nBut biology rarely lets things run away forever. Eventually, the petri dish runs out of space or food. This is where we move from the exponential to the logistic model. We add a “braking” term that slows the growth as the population approaches a carrying capacity (\\(K\\)).\n\n\n\n\n\n\nThe Beauty of the “Wrong” Model\n\n\n\nThe original Malthusian growth model (\\(\\frac{dN}{dt} = rN\\)) is “wrong” because it predicts infinite populations. But it’s the most important model ever written because it provided the starting point. In physiology, we often start with the simplest (and technically “wrong”) model because it allows us to see the primary force clearly before we add the complications of reality.\n\n\nWhy does this matter for a heart rate mentor? Because this “growth and brake” logic is the same logic used to model how a signal spreads through a neural network or how a physiological variable returns to baseline after a disturbance. It’s the first step in understanding the dance of the nerves.\n\n\n1.4.2 The “Coffee” Model: Pharmacokinetics and Drug Clearance\nLet’s get more personal. Think about that cup of coffee you had this morning. The moment you finished it, your liver started a very specific task: getting rid of the caffeine.\nYour body doesn’t clear 10mg of caffeine per hour. Instead, it clears a percentage of what is currently in your blood. This is called “First-Order Kinetics”. The less caffeine you have left, the slower the clearance becomes.\nIf \\(C\\) is the concentration of caffeine in your blood, the model looks like this:\n\\[\\frac{dC}{dt} = -kC\\]\nThe negative sign tells us the concentration is decreasing. The \\(k\\) is the clearance constant, a parameter that represents the efficiency of your enzymes.\nIn R, simulating this is trivial, but the insight is profound. It explains why a drug stays in your system for a long time (the “long tail”) and why “half-life” is such a critical concept in medicine. This simple ODE is the backbone of the entire field of pharmacokinetics. When we eventually model how adrenaline (epinephrine) clears from the heart after a sprint, we will be using this exact same blueprint.\n\n\n1.4.3 Predator and Prey: A Metaphor for Autonomic Balance\nThis is where things get really interesting. In the early 20th century, two mathematicians named Lotka and Volterra developed a model to describe the population dynamics of lynx (predators) and hares (prey).\n\nThe Hares grow exponentially if there are no lynx.\nThe Lynx die off if there are no hares to eat.\nWhen they meet, the lynx eat the hares, increasing the lynx population and decreasing the hare population.\n\nThis creates a beautiful, oscillating cycle. As the hares increase, the lynx have more food and their population booms. But then they eat too many hares, the food supply crashes, the lynx starve, and the hares get a chance to recover.\nNow, you might be wondering: What does a lynx eating a hare have to do with my heart rate?\nEverything. I want you to think of the sympathetic and parasympathetic systems as a predator-prey relationship. The sympathetic system (the predator) drives the heart rate up, while the parasympathetic system (the prey/the brake) tries to keep things in check. They are constantly “feeding” off each other’s signals to maintain a dynamic balance.\nWhile the actual math of the heart is more complex (we’ll get there in Part 3!), the Lotka-Volterra model was the first time we realized that two simple, coupled differential equations could create complex, rhythmic behavior. It proved that you don’t need a “conductor” to create a rhythm; the rhythm is an emergent property of the system’s architecture.\n\n\n1.4.4 The Hodgkin-Huxley Model: The Ghost in the Nerve\nWe can’t talk about classic models without mentioning the big one: the 1952 Hodgkin-Huxley model of the action potential. This is arguably the most famous model in the history of biology.\nBefore this model, we knew that nerves fired electrical signals, but we didn’t really know how. Hodgkin and Huxley sat down with a giant squid axon (because the nerves were big enough to poke with needles) and described the flow of sodium and potassium ions using a set of four coupled differential equations.\nThey modeled the cell membrane as an electrical circuit, with resistors, capacitors, and batteries. The Capacitor is the cell membrane itself, holding a charge. The Resistors are the ion channels, which “resist” or “allow” the flow of ions.\nThis model won them a Nobel Prize because it didn’t just describe the nerve signal; it explained it. It showed that the “spike” of a nerve impulse is just the result of voltage-gated channels opening and closing at different rates.\nWhen I talk about the architecture of life, this is what I mean. Hodgkin and Huxley looked at a messy biological fiber and saw a circuit board. They found the code.\nThink about that, a Nobel prize for seeing the soul of a nerve in the logic of a battery. That’s the kind of architecture we’re hunting for.\nI know that now you might be tempted to skip these and go straight to the “modern” stuff. However, modern models are just these classics wearing a fancy coat. When we model blood pressure, we’re using the “Growth and Brake” logic. When we model hormone signaling, we’re using “Drug Clearance” kinetics. When we model Heart Rate Variability, we’re building on the “Oscillation” principles of predator-prey systems.\nBy understanding these classics, you develop an intuition for the “shapes” of change. You start to see a graph and think, “Ah, that’s a first-order decay”, or “That looks like a coupled oscillation”. You begin to read the language of the body.\nIn the next section, we’re going to talk about why we need a tool like R to make these blueprints come to life. Because while Lotka and Volterra had to solve these by hand, you have the power of a thousand mathematicians in your RStudio console.\nI don’t want you to memorize the Lotka-Volterra equations. I want you to remember the shape of the curve. In R, we can change the parameters and watch the oscillations get wider or narrower in real-time. That visual “click” in your brain is worth more than a thousand memorized formulas.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Model Physiology?</span>"
    ]
  },
  {
    "objectID": "01-why-model-physiology.html#the-importance-of-computational-tools-like-r-for-solving-and-visualizing-models",
    "href": "01-why-model-physiology.html#the-importance-of-computational-tools-like-r-for-solving-and-visualizing-models",
    "title": "1  Why Model Physiology?",
    "section": "1.5 The Importance of Computational Tools (Like R) for Solving and Visualizing Models",
    "text": "1.5 The Importance of Computational Tools (Like R) for Solving and Visualizing Models\nI want you to picture a scene from a movie set in the 1950s. A scientist is hunched over a massive chalkboard, frantically scrawling Greek symbols, erasing them, and scrawling more. He’s trying to find the “analytical solution”, a single, perfect mathematical formula that describes everything.\nIf that scientist were trying to model the human heart, he would likely stay hunched over that chalkboard for the rest of his life.\nWhy? Because biology is stubborn. It is nonlinear, it is interconnected, and it rarely follows the neat, solvable paths we find in introductory physics textbooks. In the real world, most of the differential equations that describe living systems simply cannot be solved by hand. They don’t have a “clean” answer that you can circle in red pen.\nThis is where the keyboard becomes more powerful than the chalk. To truly understand the latent drive that makes the machine works, we need a computational partner. We need R.\n\n1.5.1 The Blackboard Barrier: Why We Can’t Do It Alone\nIn your earlier math classes, you probably solved “toy” problems. You were given an equation, and you used integration to find a function. That works fine for a falling rock or a simple bank account interest rate.\nBut physiology is a different beast. Imagine trying to write a single formula for your heart rate as it responds to:\n\nThe sudden surge of adrenaline as you start a race.\nThe feedback from baroreceptors noticing a change in blood pressure.\nThe temperature of your blood rising.\nThe accumulation of CO2 in your lungs.\n\nIn the language of math, these are “coupled, nonlinear systems”. When you change one thing, everything else shifts in a way that isn’t a straight line. If you try to solve these by hand, you hit the “Blackboard Barrier”. The math becomes so complex that the human brain, brilliant as it is, simply runs out of RAM.\nHuman intuition is great at predicting linear changes (if I walk twice as fast, I’ll get there in half the time). But we are terrible at predicting nonlinear feedback. We often overestimate short-term changes and underestimate the long-term “tipping points” in a system. Computational tools act as an “intuition prosthetic”, helping us see around the corners of complex biological logic.\nComputational tools like R don’t try to find that “one perfect formula”. Instead, they use numerical methods. They solve the equation by taking millions of tiny, infinitesimal steps forward in time. They ask, “Based on where the heart is right now, where will it be in the next 0.001 seconds?” and then they do it again, and again, and again.\n\n\n1.5.2 Why R is Our Chosen Lens\nYou might ask, “Why R? Why not Python, or MATLAB, or some specialized medical software?”\nI’m 26. I grew up in the era of open-source collaboration. To me, R isn’t just a programming language; it’s a global conversation. When you use R, you aren’t just using a tool; you’re tapping into the collective brainpower of thousands of scientists who have already figured out the hardest parts of the coding for you.\nHere is why R is the perfect lens (at least for me):\n\nThe Ecosystem of Packages: In R, we don’t have to build our “solvers” from scratch. We give it the “rules” of our physiology, and it handles the heavy lifting of the millions of tiny steps.\nVisualization as Insight: In physiology, a table of numbers is a graveyard of data. It’s dead. To make it live, we need to see it. With ggplot2, we can turn abstract equations into high-fidelity visuals. We can see the sympathetic system “climbing” and the parasympathetic system “falling” in real-time.\nReproducibility: This is huge. In the past, if a scientist built a model, you had to take their word for it. Today, I can send you my R script, and you can run the exact same simulation on your laptop. We can “interrogate” each other’s thought process.\n\n\n\n1.5.3 Making the Invisible Visible\nThe most important reason we use computational tools is to visualize emergent properties.\nThink back to the “predator-prey” model of the hares and lynx. If I just show you the equations, your brain probably doesn’t immediately see a cycle. But when we pipe those equations through R and plot them, a beautiful, rhythmic oscillation appears on the screen.\nSuddenly, the math isn’t an obstacle. You see how the heart rate “hunts” for its equilibrium. By using R to visualize our models, we are effectively giving ourselves “X-ray vision” for biological logic. We can see the invisible forces that govern our breath and our pulse.\n\n\n1.5.4 From Theory to Reality (Fast)\nIn a lab, an experiment might take weeks. In R, a simulation takes milliseconds.\nThis speed changes the way you think. When the “cost” of being wrong is just a few seconds of compute time, you become more adventurous. You start asking more “What-If” questions. What if I double the resistance in the femoral artery? What if the vagus nerve is 20% less sensitive? What if this athlete is dehydrated?\nComputational tools allow us to iterate at the speed of thought. We can build, break, and rebuild a hundred times before lunch. This is how we move from being “students of physiology” to being “explorers of systems”.\n\n\n1.5.5 The Power of the “Tidy” Workflow\nThroughout this book, we will use what’s called a “Tidy” approach. We’ll organize our model outputs into clean data frames that play nicely with the modern R ecosystem. This isn’t just about being neat; it’s about power. By keeping our data “tidy”, we can easily compare ten different versions of a model at once, or overlay our virtual “ghost” simulations directly onto real data collected from a heart rate monitor.\nI’ve learned the hard way that messy code leads to a messy understanding (and that leads to double the work). When we tidy our data, we’re actually tidying our perception of the biological world. It’s about making the architecture visible, not just functional.\n\n\n\nTraditional Modeling\nModern R Modeling\n\n\n\n\nHand-written proofs\nCoded functions\n\n\nStatic “snapshots”\nDynamic simulations\n\n\nOpaque “Black Box”\nTransparent, reproducible code\n\n\nFixed assumptions\nRapid parameter “sweeps”\n\n\n\nI know that if you haven’t coded before, looking at an RStudio console can feel like looking at the matrix. It seems cold and intimidating.\nBut remember: R is just a way to talk to the machine. And the machine is just a way to talk to the biology. We aren’t learning code for the sake of becoming “programmers”. We are learning code so we can be better physiologists. We are learning to use the most advanced tools available to understand the most ancient and beautiful architecture in existence.\nDon’t worry about the syntax yet. We’ll walk through that together in the next chapter. For now, just recognize that R is the “engine” that is going to bring our equations to life. It’s the tool that’s going to let us see the ghost.\nWe have the engine (R) and the language (ODEs). Let’s finally meet our protagonist: the human heart.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Model Physiology?</span>"
    ]
  },
  {
    "objectID": "01-why-model-physiology.html#case-study-the-rhythm-of-resilience",
    "href": "01-why-model-physiology.html#case-study-the-rhythm-of-resilience",
    "title": "1  Why Model Physiology?",
    "section": "1.6 Case Study: The Rhythm of Resilience",
    "text": "1.6 Case Study: The Rhythm of Resilience\nBefore we close the curtain on this introductory chapter and open our laptops to start typing R code, I want to give you something real to chew on. We’ve talked about the “why” and the “how” in the abstract, but the rythm of life is best understood through a specific mystery.\nThroughout this book, we will return to a recurring protagonist: the human heart. But we aren’t just looking at the heart as a pump; we are looking at it as the ultimate interface, the place where the physical body meets the electrical signals of the brain. We are going to investigate the cardiac autonomic modulation (CAM) system.\nIf you want to see the ghost that makes the machinery works, there is no better place to look than the space between two heartbeats.\n\n1.6.1 The Paradox of the Metronome\nImagine you’re sitting in a quiet room, perfectly still. You place two fingers on your radial pulse. You feel it: thump… thump… thump… It feels steady. It feels like a clock. For decades, clinicians looked at that pulse and recorded a single number, maybe 60 beats per minute (bpm). I remember looking at my first HRV trace and thinking the sensor was broken. It was too ‘noisy’. But that noise wasn’t a glitch; it was the dance of the nerves in real-time. They treated the heart like a metronome.\nBut here is the secret: a healthy heart is not a metronome. If your heart rate were perfectly regular, with exactly 1.000 seconds between every single beat, you would likely be in a state of severe physiological distress, or perhaps nearing the end of your life.\nThis dance demands a certain level of chaos. In a healthy person, the time interval between beats is constantly shifting. One interval might be 0.92 seconds, the next 1.05 seconds, and the one after that 0.88 seconds. This is Heart Rate Variability (HRV), and it is the outward “whisper” of the autonomic nervous system.\nOur case study is built around a single, driving question: How does the interaction between the sympathetic “accelerator” and the parasympathetic “brake” create the complex rhythms we see during the transition from rest to exercise?\n\n\n1.6.2 The Two Dancers: Sympathetic vs. Parasympathetic\nTo model this, we have to understand the two main characters in our story. First is the Parasympathetic Branch (The Vagus Nerve). This is the “rest and digest” system. I like to think of it as the refined, elegant dancer. It uses a neurotransmitter called acetylcholine, which works incredibly fast. The vagus nerve can slow the heart down almost instantly, within a single beat. It is the “brake” that is constantly being tapped and released to keep your heart from racing away. Second, is the Sympathetic Branch. This is the “fight or flight” system. It’s the powerhouse. It uses norepinephrine (and adrenaline from the adrenal glands). Unlike the vagus nerve, the sympathetic system is slow to start but has a long-lasting effect. It’s like a massive steam engine; it takes time to stoke the fires, but once it’s moving, it’s hard to stop.\nIn every second of your life, these two branches are engaged in a tug-of-war over the Sinoatrial (SA) node, the heart’s natural pacemaker. This is the cardiac autonomic modulation.\nWhen you decide to stand up and walk across the room, your brain doesn’t just send a “go faster” signal. It performs a complex, coordinated move: it first “withdraws” the vagal brake, allowing the heart rate to jump up quickly, and then it slowly “increases” the sympathetic gas pedal to sustain that higher rate.\n\n\n1.6.3 The Problem: Seeing the Unseen\nIf we want to understand an athlete’s recovery or a patient’s stress levels, we want to know the “tone” of these two nerves. But here is the catch: we can’t easily stick electrodes into the vagus nerve of a living human. We can see the result (the heart rate), but we can’t see the inputs (the neural firing).\nThis is why we model.\nWe can build a system of Ordinary Differential Equations where:\n\nOne equation describes the concentration of acetylcholine (the brake fluid).\nOne equation describes the concentration of norepinephrine (the fuel).\nA third equation describes how the SA node integrates these two signals to produce a heartbeat.\n\nBy adjusting the parameters of this model in R, we can simulate different “types” of people. We can create a model of a highly-trained marathoner (whose vagal brake is incredibly strong) and compare it to a model of a stressed-out office worker (whose sympathetic engine is constantly idling at high RPMs).\n\n\n\n\n\n\nThe Vagal Tone\n\n\n\nThe reason your resting heart rate isn’t 100 bpm (the natural “un-nerved” rhythm of the heart) is because of the vagus nerve. You are currently under “vagal restraint”. Your brain is actively holding your heart back. When you start to exercise, the fastest way to speed up isn’t to work harder, but to simply stop holding back. This is a fundamental principle of biological efficiency.\n\n\nI chose this case study because it’s a “multi-scale” problem. It involves molecules (neurotransmitters), organs (the heart), and the whole organism (the runner). If you can model this, you can model almost anything in physiology. Throughout the book, when the math gets a bit heavy, just think back to the sprinter at the starting line. Everything we do is for that moment.\n\n\n1.6.4 The “Exercise Onset” Challenge\nOur specific case study focuses on the first 60 seconds of exercise.\nThink about what happens when a sprinter hears the starting pistol. In those first few seconds, the heart rate skyrockets. But is that increase due to the brake being released, or the gas pedal being pushed? Or both?\nCurrent physiological theory suggests a “phased” response:\n\nPhase 1 (0-10 seconds): Pure vagal withdrawal. The brake is lifted.\nPhase 2 (10-60 seconds): Sympathetic activation kicks in. The gas pedal is pressed.\n\nIf we can build a model that replicates this “S-curve” of heart rate increase, we can start to test hypotheses. For example: If a person has a “blunted” heart rate response, is it because their vagus nerve isn’t withdrawing properly, or because their sympathetic system is sluggish?\nThis isn’t just academic. In the world of sports science, “Heart Rate Recovery”, how fast your heart rate drops in the first minute after exercise, is one of the best predictors of fitness and even longevity. By modeling the blueprint of life behind that recovery, we can move from simply saying “your recovery is slow” to saying “your vagal reactivation is delayed by X seconds”.\n\n\n1.6.5 What Lies Ahead\nIn the chapters to come, we will build the pieces of this case study step-by-step: 1. Chapter 3 & 4: We’ll learn the math of “rates” so we can describe how fast acetylcholine disappears. 2. Chapter 9: We’ll build the basic cardiovascular “pump” model. 3. Chapter 10 & 12: We’ll finally wire the “nerves” to the “pump” and run our full exercise simulations.\nBefore we move on to Chapter 2 and start our R setup, I want you to remember this: every line of code you write is a step toward understanding how we maintain balance in a world that is constantly trying to push us off-center. We are building the blueprint of resilience.\nAre you ready to see the ghost? Take a breath. Feel your own heart rate, that’s the system we’re about to build. I’ll see you in Chapter 2, where we turn this philosophy into code",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Model Physiology?</span>"
    ]
  },
  {
    "objectID": "02-a_gentle_introduction_to_r_for_modelers.html",
    "href": "02-a_gentle_introduction_to_r_for_modelers.html",
    "title": "2  A Gentle Introduction to R for Modelers",
    "section": "",
    "text": "2.1 Setting up R and RStudio\nWelcome to Chapter 2! In Chapter 1, we made the case for using mathematical modeling, particularly with differential equations, to understand the dynamic complexities of physiological systems. We highlighted that to actually implement, solve, and visualize these models, computational tools are essential. For this book, our tool of choice is the R programming environment, coupled with the user-friendly RStudio interface.\nThis chapter will provide you with a gentle introduction to the R skills you’ll need for modeling. We won’t aim to make you a master programmer, but rather to equip you with the fundamental knowledge and practical R commands necessary to follow along with the modeling examples throughout the rest of the book. We start here with getting the software set up on your computer.\nYou will need two main software components:\nBoth R and RStudio are free and open-source, available for Windows, macOS, and Linux operating systems.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A Gentle Introduction to R for Modelers</span>"
    ]
  },
  {
    "objectID": "02-a_gentle_introduction_to_r_for_modelers.html#setting-up-r-and-rstudio",
    "href": "02-a_gentle_introduction_to_r_for_modelers.html#setting-up-r-and-rstudio",
    "title": "2  A Gentle Introduction to R for Modelers",
    "section": "",
    "text": "R: This is the statistical programming language itself – the engine that performs calculations, runs simulations, and executes commands.\nRStudio: This is a powerful and user-friendly Integrated Development Environment (IDE) for R. Think of R as the car’s engine and RStudio as the dashboard, steering wheel, and comfortable seats. While you can interact directly with the R engine using a basic console, RStudio makes coding, managing files, viewing plots, and accessing help much, much easier. It’s highly recommended to use RStudio when working with R.\n\n\n\n2.1.1 Step 1: Download and Install R\nFirst, you need to install the R programming language.\n\nGo to the Comprehensive R Archive Network (CRAN) website. You can find it by searching for “CRAN R” or by navigating directly to [Insert CRAN URL here, e.g., https://cran.r-project.org/].\nOn the CRAN website, find the download link appropriate for your operating system (Linux, macOS, or Windows).\nFollow the instructions for your specific OS to download the latest version of R.\nOnce the download is complete, run the installer file. For most users, accepting the default installation options is recommended. Choose the installation directory, components, and startup options that are pre-selected unless you have a specific reason to change them.\n\n\n\n2.1.2 Step 2: Download and Install RStudio Desktop\nNext, download and install RStudio.\n\nGo to the Posit website (Posit is the company that develops RStudio, formerly known as RStudio, PBC). You can find the download page by searching for “Download RStudio Desktop” or by navigating to [Insert Posit RStudio download URL here, e.g., https://posit.co/download/rstudio-desktop/].\nOn the download page, locate the section for “RStudio Desktop”. Choose the FREE version – this version has all the capabilities you will need for this book.\nSelect the download link that matches your operating system.\nOnce the download is complete, run the installer file. Again, accepting the default installation options is typically the best approach unless you have specific IT requirements.\n\n\n\n2.1.3 Step 3: Verify Installation\nAfter installing both R and RStudio, open RStudio. You should be able to find it in your applications or programs menu just like any other software.\nWhen RStudio opens, it should automatically detect the R installation on your system. You’ll typically see several panes (windows) within the RStudio interface, including a Console pane where you can type R commands. If RStudio launches without errors, congratulations! You have successfully set up your modeling environment.\nWhile installation is usually a straightforward process, computer configurations can vary. If you encounter issues during installation, consult the official R and RStudio installation guides online, or refer to Appendix A (if included) which might cover common troubleshooting steps.\nWith R and RStudio successfully installed, you have the essential computational tools ready. You are now prepared to begin exploring the basics of the R language and how we will use it as our workbench to build, solve, and visualize physiological models.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A Gentle Introduction to R for Modelers</span>"
    ]
  },
  {
    "objectID": "02-a_gentle_introduction_to_r_for_modelers.html#basic-r-syntax-data-types-and-operations",
    "href": "02-a_gentle_introduction_to_r_for_modelers.html#basic-r-syntax-data-types-and-operations",
    "title": "2  A Gentle Introduction to R for Modelers",
    "section": "2.2 Basic R syntax, data types, and operations",
    "text": "2.2 Basic R syntax, data types, and operations\nWith R and RStudio successfully installed, you now have the essential tools to begin your journey into physiological modeling. Think of RStudio as your laboratory workbench – it’s where you will write the instructions for your models, perform simulations, analyze results, and create visualizations.\nThis chapter is designed to give you just enough familiarity with R’s fundamental building blocks to get started. We will focus only on the concepts and syntax that are directly relevant to defining, solving, and interacting with differential equation models later in the book. Don’t feel the need to become an R expert overnight; our aim is practical application for modeling physiological dynamics.\nLet’s begin by getting acquainted with the RStudio interface and some very basic operations.\n\n2.2.1 Getting Around RStudio\nWhen you open RStudio, you will typically see several panes. While the exact layout can be customized, the default setup usually includes:\n\nSource Editor (Top-Left): This is where you’ll write your R scripts (.R files). Writing code in a script is crucial because it allows you to save your work, easily edit it, and run lines of code repeatedly. This is where you’ll define your differential equations as R functions.\nConsole (Bottom-Left): This pane is where R commands are executed. You can type commands directly here and press Enter to run them. R’s output (results, messages, warnings, errors) will appear here. When you run code from your script in the Source Editor, it gets sent to the Console to be executed.\nEnvironment/History (Top-Right): The Environment tab shows you all the objects (variables, data, functions) that you currently have loaded in R’s memory. This is useful for keeping track of your model parameters and simulation results. The History tab shows you previous commands you’ve run in the Console.\nFiles/Plots/Packages/Help/Viewer (Bottom-Right): This pane is multi-functional.\n\nFiles: Navigate your computer’s file system. Useful for opening scripts or finding data files.\nPlots: This is where visualizations (graphs) generated by your R code will appear. A critical pane for visualizing model outputs!\nPackages: Lists installed R packages and allows you to load or unload them. We’ll use this to ensure deSolve and ggplot2 are ready.\nHelp: Search for and view documentation for R functions and packages. Invaluable when you forget how a function works.\nViewer: Can display local web content, sometimes used for interactive visualizations.\n\n\nGet comfortable identifying these panes. You’ll primarily work by writing code in the Source Editor and running it in the Console, keeping an eye on your variables in the Environment and your plots in the Plots pane.\n\n\n2.2.2 R as a Calculator: Basic Operations\nAt its most fundamental level, R can be used like a sophisticated calculator. You can type mathematical expressions directly into the Console and press Enter to see the result.\n\n10 + 5\n\n[1] 15\n\n\n\n25 * 3 - 10\n\n[1] 65\n\n\n\n(100 / 5) + (15 * 2)\n\n[1] 50\n\n\nR understands the standard order of operations (parentheses/brackets, exponents, multiplication/division, addition/subtraction – PEMDAS/BODMAS). You can use parentheses to ensure calculations are performed in the order you intend.\nBasic arithmetic operators:\n\n+ Addition\n- Subtraction\n* Multiplication\n/ Division\n^ or ** Exponentiation (e.g., 2^3 is 2 cubed)\n\n\n\n2.2.3 Variables and Assignment: Storing Information\nIn modeling, we need to store values like physiological parameters (e.g., clearance rate, sensitivity), initial conditions (e.g., starting drug concentration, initial heart rate), and eventually, the results of our simulations. We do this using variables, also called objects in R.\nYou assign a value to a variable using the assignment operator, which is typically &lt;- (a less-than sign followed by a hyphen). You can also use =, but &lt;- is considered the standard and often preferred style in R programming.\nLet’s create a variable to store a resting heart rate value:\n\nresting_HR &lt;- 65\n\nWhen you run this line in the Console (or run it from a script), you won’t see output in the Console, but you will see resting_HR appear in your Environment pane with the value 65.\nNow you can use this variable in calculations:\n\nmax_HR &lt;- 220 - 40 # Let's assume age 40\n\nHR_range &lt;- max_HR - resting_HR\n\nprint(HR_range)\n\n[1] 115\n\n\nYou can also assign the result of a calculation to a variable:\n\nBMI &lt;- 75 / (1.80^2) # Mass (kg) / Height (m)^2\n\nprint(BMI)\n\n[1] 23.14815\n\n\nVariable names in R can contain letters, numbers, underscores (_), and periods (.). They cannot start with a number or underscore. R is also case-sensitive, meaning resting_HR, Resting_HR, and resting_hr would be treated as three different variables. Choose names that are descriptive and easy to read.\nR Tip: Use descriptive variable names! clearance_rate is much better than k, especially in complex models.\n\n\n2.2.4 Data Types: What Kind of Data is It?\nEvery piece of data in R has a data type or class. R handles many types automatically, but being aware of the basic ones is helpful. For physiological modeling, the most important type is numeric.\n\nNumeric. This is the default type for numbers in R. It includes real numbers (with decimal places, often called ‘double’ or ‘float’ in other languages) and integers (whole numbers). R treats most numbers you enter as numeric. Parameters and state variables in our models will almost always be numeric.\n\n\nheart_rate &lt;- 72.5 # Numeric (double)\nage &lt;- 30         # Numeric (integer, but often treated as double)\nrate_constant &lt;- 0.15 # Numeric (double)\n\n\nCharacter. Used for text or strings. You enclose character data in quotes (\" or '). Useful for labels, names, or text output.\n\n\nsubject_id &lt;- \"Subject_001\"\nmeasurement_unit &lt;- \"bpm\"\n\n\nLogical. Represents Boolean values, TRUE or FALSE. Results from logical comparisons (e.g., 5 &gt; 3 is TRUE). Less common in basic ODE definition but fundamental for control flow in programming.\n\n\nis_exercising &lt;- TRUE\nis_resting &lt;- FALSE\n\nYou can check the class of an object using the class() function:\n\nclass(heart_rate)\n\n[1] \"numeric\"\n\n\n\nclass(subject_id)\n\n[1] \"character\"\n\n\nFor our physiological modeling, you will primarily work with numeric data types for your state variables, parameters, initial conditions, and time points.\n\n\n2.2.5 Using Built-in R Functions\nR comes with a vast library of built-in functions to perform operations. You’ve already seen class(). Functions take inputs (arguments) inside parentheses () and perform an action or calculation, returning an output.\nMany mathematical functions are readily available and will be useful when defining the rate functions for your differential equations:\n\nsqrt(81) # Square root\n\n[1] 9\n\n\n\nexp(1)   # The exponential function e^x (e to the power of 1)\n\n[1] 2.718282\n\n\n\nlog(10)  # Natural logarithm (base e)\n\n[1] 2.302585\n\n\n\nlog10(100) # Logarithm base 10\n\n[1] 2\n\n\n\nsin(pi / 2) # Sine function (input in radians)\n\n[1] 1\n\n\nYou can use variables within functions, and functions within calculations:\n\ninitial_concentration &lt;- 100\ndecay_rate &lt;- 0.05\ntime_point &lt;- 10\n\n# Concentration after 10 time units using the exponential decay formula\npredicted_concentration &lt;- initial_concentration * exp(-decay_rate * time_point)\n\nprint(predicted_concentration)\n\n[1] 60.65307\n\n\nThis simple example shows how R handles the exact solution of a simple exponential decay model, even before we get to solving differential equations numerically.\nFunctions can take multiple arguments, separated by commas. For example, round() takes a number and the number of decimal places to round to:\n\nround(BMI, 2)\n\n[1] 23.15\n\n\n\n\n2.2.6 Getting Help in R\nOne of the most important R skills is knowing how to get help. If you know the name of a function but aren’t sure how to use it or what its arguments are, type a question mark followed by the function name in the Console and press Enter:\n?exp\nThis will open the help page for the exp() function in the Help pane (bottom-right). Help pages might look technical at first, but they contain essential information about a function’s description, usage (how to call it, its arguments), details, and examples.\n\n\n2.2.7 Adding Comments to Your Code\nAs your R code grows, it’s crucial to add comments to explain what you’re doing. This makes your code readable for yourself later and for anyone else who might need to understand your physiological model code. In R, anything on a line after a # symbol is treated as a comment and ignored by R when executing the code.\n\n# This line calculates the maximum heart rate based on age\nmax_HR &lt;- 220 - 40\n\n# Let's define some parameters for a simple model\nclearance_k &lt;- 0.1  # Clearance rate constant (units: 1/time)\ninitial_C &lt;- 50     # Initial concentration (units: mass/volume)\n\n\n\n\n\n\n\nInsight\n\n\n\nUse comments generously when building your models to explain the physiological meaning of different parts of your code, parameters, and equations.\n\n\n\n\n2.2.8 Using the Script Editor\nWhile the Console is great for quick calculations or trying out single commands, you should write the code for your models, simulations, and plots in the Source Editor (top-left pane). This allows you to save your work as an R script file (with a .R extension).\nTo create a new R script, go to File &gt; New File &gt; R Script. You can type multiple lines of code in this editor. To run a specific line or a block of lines from the script, place your cursor on the line or select the block and press Ctrl + Enter (on Windows/Linux) or Cmd + Enter (on macOS). The code will be sent to the Console and executed.\nSaving your script (File &gt; Save As...) means you don’t lose your work and can easily re-run your entire model or simulation later.\n\n\n2.2.9 Workspace and Saving Your Work\nThe Environment pane (top-right) shows you the R “workspace” – all the objects (variables, functions) currently loaded in your session. When you close RStudio, it might ask if you want to save your workspace. Saving the workspace (.RData file) saves all the objects in your Environment, so they are there when you open RStudio again in that project directory. However, it is generally better practice for reproducibility to save your scripts (.R files) and ensure that running the script from beginning to end recreates all necessary objects. This way, you have a clear record of how your data and variables were created.\nTry It Yourself:\n\nOpen a new R script in RStudio (File &gt; New File &gt; R Script).\nIn the script, define variables for body mass (kg) and height (m).\nCalculate BMI using these variables and assign it to a bmi_value variable.\nAdd comments to your code explaining each step.\nRun each line of your script using Ctrl + Enter (or Cmd + Enter). Observe the variables appearing in your Environment pane.\nUse the round() function to round your bmi_value to one decimal place.\nUse ?round in the Console to open the help page for the round() function.\nSave your script (File &gt; Save As...).\n\nIn this section, you’ve taken your first steps with R. You’ve learned how to use RStudio, perform basic arithmetic, store values in variables (objects) of different data types (focusing on numeric), use built-in functions, get help, and write code in a script file. These are the fundamental building blocks. Don’t worry if it feels basic right now. As we progress, you will use these exact skills, combined with R’s powerful packages, to define and work with your physiological differential equation models. In the next section, we’ll introduce how R handles collections of data, which is essential for working with multiple state variables and simulation outputs.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A Gentle Introduction to R for Modelers</span>"
    ]
  },
  {
    "objectID": "02-a_gentle_introduction_to_r_for_modelers.html#working-with-vectors-matrices-and-data-frames",
    "href": "02-a_gentle_introduction_to_r_for_modelers.html#working-with-vectors-matrices-and-data-frames",
    "title": "2  A Gentle Introduction to R for Modelers",
    "section": "2.3 Working with vectors, matrices, and data frames",
    "text": "2.3 Working with vectors, matrices, and data frames\nIn the previous section, we learned how to use R as a calculator and store single values in variables. However, physiological data and the output from our dynamic models are rarely single numbers. We work with sequences of measurements over time, data collected from multiple subjects, or the simultaneous values of several physiological variables. To handle this, R provides powerful structures for organizing collections of data: vectors, matrices, and data frames. Understanding these is fundamental to working with physiological data and interpreting model outputs in R.\nThink of these structures as different ways to organize numbers (and other data types) in a table or list, each suited for slightly different purposes.\n\n2.3.1 Vectors: Sequences of Data Points\nThe most basic R data structure is a vector. A vector is simply a sequence of elements of the same data type (usually numbers for our purposes). You can think of it as a single row or a single column of numbers.\nPhysiologically, a vector is a natural way to represent:\n\nA series of heart rate measurements taken every minute during an exercise test.\nA set of parameter values for a model (e.g., rate constants for drug clearance, sensitivity values for autonomic control).\nA list of subject IDs or group assignments.\n\nYou create a vector using the c() function (which stands for “combine” or “concatenate”). You place the elements you want in the vector inside the parentheses, separated by commas.\n\n# A vector of heart rate measurements (beats per minute) at different time points\nheart_rates &lt;- c(60, 72, 95, 120, 145, 150, 152)\n\n# A vector of corresponding time points (in minutes)\ntime_points_min &lt;- c(0, 1, 2, 3, 4, 5, 6)\n\n# A vector of model parameters (e.g., for a simple physiological model)\nmodel_params &lt;- c(0.05, 1.2, 70) # clearance_rate, volume, baseline_value\n\nWhen you print a vector by typing its name in the console, R shows its contents:\n\nheart_rates\n\n[1]  60  72  95 120 145 150 152\n\n\nThe [1] indicates that the first element shown is the first element of the vector. If a vector is very long, R will print it across multiple lines and indicate the index of the first element on each line.\nYou can get basic information about a vector:\n\nlength(heart_rates) # How many elements are in the vector?\n\n[1] 7\n\nclass(heart_rates) # What type of data is stored in the vector?\n\n[1] \"numeric\"\n\n\nAccessing Elements in a Vector\nYou can access individual elements or subsets of elements in a vector using square brackets [] after the vector name. The numbers inside the brackets are the indices (positions) of the elements you want, starting with 1 for the first element.\n\nheart_rates[1] # Access the first element\n\n[1] 60\n\nheart_rates[4] # Access the fourth element (120 bpm)\n\n[1] 120\n\nheart_rates[c(1, 3, 7)] # Access multiple elements using a vector of indices\n\n[1]  60  95 152\n\nheart_rates[2:5] # Access a range of elements using the colon operator (:)\n\n[1]  72  95 120 145\n\nheart_rates[-1] # Access all elements EXCEPT the first one\n\n[1]  72  95 120 145 150 152\n\n\nTry It Yourself:\nCreate a vector called body_weights_kg with the weights of 5 subjects: 70.5, 65.2, 80.1, 72.9, 68.0.\n\nHow many subjects are in this vector?\nWhat is the weight of the 3rd subject?\nGet the weights of the 1st, 2nd, and 5th subjects.\n\nVector Operations\nOne of the most powerful features of vectors in R is that arithmetic operations typically work element-wise. This means you can perform calculations on every element of a vector simultaneously without writing a loop.\n\n# Convert heart rates from bpm to beats per second\nheart_rates_bps &lt;- heart_rates / 60\n\nprint(heart_rates_bps)\n\n[1] 1.000000 1.200000 1.583333 2.000000 2.416667 2.500000 2.533333\n\n# Add a constant value to all elements (e.g., simulating a measurement offset)\nheart_rates_offset &lt;- heart_rates + 5\n\nprint(heart_rates_offset)\n\n[1]  65  77 100 125 150 155 157\n\n\nIf you perform an operation on two vectors of the same length, the operation is applied between corresponding elements:\n\n# Let's say we measured change in blood pressure (mmHg) at the same time points\ndelta_bp_mmhg &lt;- c(0, 5, 10, 15, 20, 22, 20)\n\n# Calculate a simple physiological stress index (just for illustration)\n# Maybe stress_index = HR * delta_BP\nstress_index &lt;- heart_rates * delta_bp_mmhg\n\nprint(stress_index)\n\n[1]    0  360  950 1800 2900 3300 3040\n\n\nYou can also use many built-in functions on vectors, which often return a single value summarizing the vector:\n\nmean(heart_rates) # Calculate the average heart rate\n\n[1] 113.4286\n\nsum(delta_bp_mmhg) # Calculate the total change in BP (not physiologically meaningful here, just an example)\n\n[1] 92\n\nmax(heart_rates) # Find the maximum heart rate\n\n[1] 152\n\nmin(heart_rates) # Find the minimum heart rate\n\n[1] 60\n\n\nVectors are fundamental for storing lists of numbers or single physiological variables over time or across subjects. In modeling, they are also commonly used to define the initial conditions of your model variables and to store model parameters.\n\n\n2.3.2 Matrices: Two-Dimensional Arrays\nA matrix is a two-dimensional collection of elements, arranged in rows and columns, where all elements must be of the same data type. You can think of it as a rectangular table of numbers.\nMatrices are useful in R for representing certain mathematical structures (like transformation matrices, if you were doing more complex linear algebra) or sometimes for organizing parameter sets for multiple model runs. However, for typical physiological data management, data frames (discussed next) are usually more flexible and common.\nYou can create a matrix using the matrix() function. You provide a vector of the data, the number of rows (nrow), and the number of columns (ncol). By default, matrices are filled column by column.\n\n# Create a matrix of physiological data (e.g., HR and BP for 3 time points)\n# Let's arrange data as: Col 1 = HR, Col 2 = BP\n# Data vector: 60, 120 (HR), 80, 140 (BP)\nphys_matrix_data &lt;- c(60, 80, 120, 140, 90, 130) # HR data then BP data\n\nphys_matrix &lt;- matrix(\n  data = phys_matrix_data, \n  nrow = 3, \n  ncol = 2\n)\n\nprint(phys_matrix)\n\n     [,1] [,2]\n[1,]   60  140\n[2,]   80   90\n[3,]  120  130\n\n\nBut wait, this filled column by column! Let’s specify byrow = TRUE\nCorrecting matrix creation to fill by row:\n\nphys_matrix_data_byrow &lt;- c(60, 120, # Time 1: HR, BP\n                            80, 140, # Time 2: HR, BP\n                            90, 130) # Time 3: HR, BP\n\nphys_matrix_corrected &lt;- matrix(\n  data = phys_matrix_data_byrow, \n  nrow = 3, \n  ncol = 2, \n  byrow = TRUE\n)\n\nprint(phys_matrix_corrected)\n\n     [,1] [,2]\n[1,]   60  120\n[2,]   80  140\n[3,]   90  130\n\n\nStill not right, data order matters! Let’s arrange the data vector column by column for the default fill:\n\n# Data vector: HR at 3 times, then BP at 3 times\nphys_matrix_data_cols &lt;- c(60, 80, 90, # HR at times 1, 2, 3\n                           120, 140, 130) # BP at times 1, 2, 3\n\nphys_matrix_bycol &lt;- matrix(\n  data = phys_matrix_data_cols,\n  nrow = 3, \n  ncol = 2\n)\n\nphys_matrix_bycol\n\n     [,1] [,2]\n[1,]   60  120\n[2,]   80  140\n[3,]   90  130\n\n\nThis looks better. Column 1 is HR, Column 2 is BP.\nYou can access elements, rows, or columns of a matrix using [row, column]. Leave the row or column part blank to select an entire row or column.\n\nphys_matrix_bycol[1, 1] # Element in row 1, column 1 (HR at time 1)\n\n[1] 60\n\nphys_matrix_bycol[2, ] # Entire second row (HR and BP at time 2)\n\n[1]  80 140\n\nphys_matrix_bycol[, 1] # Entire first column (HR at all times) - this is a vector!\n\n[1] 60 80 90\n\n\nTry It Yourself:\nCreate a matrix named training_load with 4 rows (subjects) and 2 columns (Session 1 Load, Session 2 Load). Fill it with some numerical values (e.g., RPE, weight lifted, arbitrary units).\n\nAccess the load from Session 2 for the 3rd subject.\nAccess all loads for the 1st subject.\nAccess the loads from Session 1 for all subjects.\n\nMatrices are less common for raw experimental data in R compared to data frames, but they might appear when you deal with specific types of model outputs or perform operations that result in a matrix structure.\n\n\n2.3.3 Data Frames: The Workhorse for Tabular Data\nFor organizing most physiological experimental data and for handling the output of ODE solvers in R, the data frame is the most important data structure. A data frame is essentially a list of vectors of the same length, where each vector is a column. Unlike a matrix, different columns in a data frame can have different data types (e.g., one column can be numbers, another can be text, another can be logical values).\nThink of a data frame as a spreadsheet or a table in a database, where each column represents a different variable (Time, HeartRate, BloodPressure, SubjectID, Group) and each row represents an observation or a subject at a specific time point.\nYou create a data frame using the data.frame() function, where each argument is a vector that will become a column. You can name the arguments to set the column names.\n\n# Our earlier vectors\ntime_points_min &lt;- c(0, 1, 2, 3, 4, 5, 6)\nheart_rates &lt;- c(60, 72, 95, 120, 145, 150, 152)\ndelta_bp_mmhg &lt;- c(0, 5, 10, 15, 20, 22, 20)\nsubject_id &lt;- c(\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\") # A character vector\n\n# Create a data frame from these vectors\nexercise_data &lt;- data.frame(Time = time_points_min,\n                            HeartRate = heart_rates,\n                            DeltaBP = delta_bp_mmhg,\n                            Subject = subject_id)\n\nexercise_data\n\n  Time HeartRate DeltaBP Subject\n1    0        60       0       A\n2    1        72       5       A\n3    2        95      10       A\n4    3       120      15       A\n5    4       145      20       A\n6    5       150      22       A\n7    6       152      20       A\n\n\nThis data frame clearly organizes our physiological measurements by time point and variable.\nInspecting Data Frames\nBefore working with a data frame, it’s useful to get a quick overview:\n\n# View the first few rows (useful for large datasets)\nhead(exercise_data)\n\n  Time HeartRate DeltaBP Subject\n1    0        60       0       A\n2    1        72       5       A\n3    2        95      10       A\n4    3       120      15       A\n5    4       145      20       A\n6    5       150      22       A\n\n# Get summary statistics for each column\nsummary(exercise_data)\n\n      Time       HeartRate        DeltaBP        Subject         \n Min.   :0.0   Min.   : 60.0   Min.   : 0.00   Length:7          \n 1st Qu.:1.5   1st Qu.: 83.5   1st Qu.: 7.50   Class :character  \n Median :3.0   Median :120.0   Median :15.00   Mode  :character  \n Mean   :3.0   Mean   :113.4   Mean   :13.14                     \n 3rd Qu.:4.5   3rd Qu.:147.5   3rd Qu.:20.00                     \n Max.   :6.0   Max.   :152.0   Max.   :22.00                     \n\n# Get the names of the columns\ncolnames(exercise_data)\n\n[1] \"Time\"      \"HeartRate\" \"DeltaBP\"   \"Subject\"  \n\n# Show the structure and data types of each column\nstr(exercise_data)\n\n'data.frame':   7 obs. of  4 variables:\n $ Time     : num  0 1 2 3 4 5 6\n $ HeartRate: num  60 72 95 120 145 150 152\n $ DeltaBP  : num  0 5 10 15 20 22 20\n $ Subject  : chr  \"A\" \"A\" \"A\" \"A\" ...\n\n# Show the dimensions (rows, columns)\ndim(exercise_data)\n\n[1] 7 4\n\n\nAccessing Data Frame Elements, Rows, and Columns\nAccessing data in a data frame is similar to matrices and vectors, but with additional convenient methods.\n\nUsing [row, column]: Same as matrices.\n\n\nexercise_data[1, 2] # Heart rate at the first time point\n\n[1] 60\n\nexercise_data[3, ] # All data for the third time point\n\n  Time HeartRate DeltaBP Subject\n3    2        95      10       A\n\nexercise_data[, 2] # All heart rates (returns a vector)\n\n[1]  60  72  95 120 145 150 152\n\n\n\nUsing the $ Operator: This is the most common way to access an entire column by its name. It returns a vector.\n\n\nexercise_data$HeartRate # Get the entire HeartRate column as a vector\n\n[1]  60  72  95 120 145 150 152\n\nexercise_data$Time\n\n[1] 0 1 2 3 4 5 6\n\n\n\nUsing [, \"column_name\"]: Another way to access a column by name using the square brackets.\n\n\nexercise_data[, \"DeltaBP\"] # Get the DeltaBP column\n\n[1]  0  5 10 15 20 22 20\n\n\nAdding New Columns\nYou can easily add new columns to a data frame, often by performing calculations on existing columns.\n\n# Assume RestingBP is 80 mmHg. Calculate AbsoluteBP\nexercise_data$AbsoluteBP &lt;- 80 + exercise_data$DeltaBP\n\n# Calculate Heart Rate Reserve (HRR) if max HR is 190\nmax_hr &lt;- 190\nresting_hr &lt;- 60\nhrr &lt;- max_hr - resting_hr\n\nexercise_data$HRR_percent &lt;- 100 * (exercise_data$HeartRate - resting_hr) / hrr\n\nprint(exercise_data) # View the updated data frame\n\n  Time HeartRate DeltaBP Subject AbsoluteBP HRR_percent\n1    0        60       0       A         80    0.000000\n2    1        72       5       A         85    9.230769\n3    2        95      10       A         90   26.923077\n4    3       120      15       A         95   46.153846\n5    4       145      20       A        100   65.384615\n6    5       150      22       A        102   69.230769\n7    6       152      20       A        100   70.769231\n\n\nSubsetting Data Frames\nSelecting specific rows (observations) based on conditions is a common task. You can use logical conditions within the square brackets.\n\n# Select only the rows where HeartRate is greater than 100 bpm\nhigh_hr_data &lt;- exercise_data[exercise_data$HeartRate &gt; 100, ]\n\nprint(high_hr_data)\n\n  Time HeartRate DeltaBP Subject AbsoluteBP HRR_percent\n4    3       120      15       A         95    46.15385\n5    4       145      20       A        100    65.38462\n6    5       150      22       A        102    69.23077\n7    6       152      20       A        100    70.76923\n\n# Select rows where Time is between 2 and 5 minutes (inclusive)\n# Use '&' for 'and'\nmid_exercise_data &lt;- \n  exercise_data[exercise_data$Time &gt;= 2 & exercise_data$Time &lt;= 5, ]\n\nprint(mid_exercise_data)\n\n  Time HeartRate DeltaBP Subject AbsoluteBP HRR_percent\n3    2        95      10       A         90    26.92308\n4    3       120      15       A         95    46.15385\n5    4       145      20       A        100    65.38462\n6    5       150      22       A        102    69.23077\n\n\nNotice the comma after the condition exercise_data$HeartRate &gt; 100. This indicates we are selecting rows. If you wanted to select specific rows and specific columns, you would specify both (e.g., exercise_data[exercise_data$Time &gt;= 2, c(\"Time\", \"HeartRate\")]). Leaving the column part blank selects all columns.\nData Frames and Model Output\nWhy is understanding data frames so important for this book? Because the standard output from R packages that solve differential equations, like the deSolve package we will use extensively, is a data frame!\nWhen you simulate a physiological model with deSolve, the result will be a data frame where:\n\nThe first column contains the time points.\nSubsequent columns contain the predicted values of each of your state variables (HeartRate, SympatheticTone, etc.) at those time points.\n\nYou will then use the techniques learned in this section – accessing columns by name ($), selecting specific rows (e.g., for a time window), and using these columns as vectors – to analyze the simulation results and create visualizations.\nTry It Yourself:\nUsing the exercise_data data frame you created:\n\nGet the average AbsoluteBP.\nSelect only the rows where HRR_percent is greater than 50%.\nCalculate the mean HeartRate for the time points where DeltaBP is exactly 20 mmHg.\n\nVectors, matrices, and data frames are the fundamental structures for organizing data in R. Vectors are sequences of the same type, useful for lists of parameters or single variables over time. Matrices are 2D arrays of the same type. Data frames are the most flexible, allowing columns of different types and serving as the standard format for tabular data, including the crucial time-series output from our differential equation models.\nMastering how to create, inspect, access, and perform basic operations on data frames is a critical step. With these skills, you are well-equipped to handle the experimental data you might want to compare your models against, and crucially, to work with the simulated time courses that your models will produce in R. In the next section, we’ll look at how to get your existing physiological data into R by importing files.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A Gentle Introduction to R for Modelers</span>"
    ]
  },
  {
    "objectID": "02-a_gentle_introduction_to_r_for_modelers.html#importing-and-exporting-data",
    "href": "02-a_gentle_introduction_to_r_for_modelers.html#importing-and-exporting-data",
    "title": "2  A Gentle Introduction to R for Modelers",
    "section": "2.4 Importing and exporting data",
    "text": "2.4 Importing and exporting data\nMuch of the power of mathematical modeling comes from its ability to help us interpret and understand real-world data. In your research, you collect physiological measurements – heart rate, blood pressure, gas exchange variables, EMG signals, force output, and many others. To compare your model simulations to these experimental results, or to use your data to inform model parameters, you first need to get this data into R. Similarly, after running a model simulation, you might want to save the predicted time course of your variables to a file for later analysis or sharing.\nThis section will cover the essential skills for importing data from external files into R and exporting data (like your simulation results) from R to files.\nAs we learned in the previous section, R’s data frame structure is perfectly suited for handling tabular data – the rows represent observations (e.g., time points, subjects), and the columns represent different variables (e.g., Time, HeartRate, VO2, SubjectID). Most physiological data you’ll encounter in spreadsheets or text files can be easily imported into an R data frame.\n\n2.4.1 Setting Your Working Directory\nBefore importing or exporting files, it’s crucial to understand R’s working directory. The working directory is the default folder on your computer where R will look for files to read and where it will save files you export.\nIf you don’t set your working directory, you’ll have to type the full path to your file every time you want to access it, which can be cumbersome and prone to errors. It’s best practice to set your working directory to the folder where your data files are stored for a particular project.\nYou can check your current working directory using the getwd() function:\ngetwd()\n# [1] \"/Users/yourusername/Documents\" # Example output - this will vary!\nYou can change your working directory using the setwd() function. Replace \"path/to/your/data/folder\" with the actual path on your computer:\n# Example for macOS/Linux:\nsetwd(\"/Users/yourusername/Documents/PhysioModelingProject/Data\")\n\n# Example for Windows (note forward slashes or double backslashes):\nsetwd(\"C:/Users/yourusername/Documents/PhysioModelingProject/Data\")\n# OR\nsetwd(\"C:\\\\Users\\\\yourusername\\\\Documents\\\\PhysioModelingProject\\\\Data\")\nIn RStudio, you can also set the working directory using the GUI: Session -&gt; Set Working Directory -&gt; Choose Directory... Navigate to your desired folder and click “Open”. RStudio will automatically generate and run the setwd() command for you in the Console. Using RStudio’s interface is often easier than typing paths manually.\nOnce you’ve set your working directory, R will look for files in that folder.\n\n\n2.4.2 Importing Data from Text Files (CSV and Tab-delimited)\nTwo of the most common formats for sharing tabular data are CSV (Comma Separated Values) and tab-delimited text files. These are plain text files where columns are separated by a specific character (a comma for CSV, a tab for tab-delimited files), and rows are separated by new lines. They can be easily created or exported from spreadsheet programs like Excel or data acquisition software.\nImporting CSV Files (.csv)\nCSV files are perhaps the most common. In a CSV file, columns are separated by commas. Here’s how to read a CSV file into an R data frame using the read.csv() function:\n# Assuming you have a file named \"exercise_hr_vo2.csv\" in your working directory\n# The file might look something like this:\n# Time,HR,VO2\n# 0,60,0.3\n# 1,70,0.8\n# 2,90,1.5\n# 3,120,2.5\n\n# Read the CSV file into a data frame\nmy_phys_data &lt;- read.csv(\"exercise_hr_vo2.csv\")\nBy default, read.csv() assumes:\n\nThe first row of the file contains the column headers (header = TRUE).\nColumns are separated by commas (sep = \",\").\nText columns should be converted into factors. For data analysis and modeling, converting text into factors can sometimes be problematic or unnecessary. You can often prevent this by adding the argument stringsAsFactors = FALSE.\n\nSo, a more robust way to read your CSV might be:\nmy_phys_data &lt;- read.csv(\"exercise_hr_vo2.csv\", header = TRUE, stringsAsFactors = FALSE)\nAfter importing, it’s crucial to inspect the data frame to ensure it was read correctly:\nhead(my_phys_data) # View the first few rows\nsummary(my_phys_data) # Get summary statistics\nstr(my_phys_data) # Check the structure and data types of columns\nCheck if the column names are correct and if the data types are as expected (e.g., Time, HR, and VO2 should be numeric).\nImporting Tab-Delimited Files (.txt, .tsv)\nTab-delimited files are similar to CSV but use tabs (\\t) instead of commas to separate columns. You can use the read.table() function with sep=\"\\t\" or the convenience function read.delim().\n# Assuming you have a file named \"subject_data.txt\" in your working directory\n# The file might look like this:\n# SubjectID Age Gender  Group\n# S1    25  Male    Trained\n# S2    30  Female  Untrained\n# S3    28  Male    Trained\n\n# Read the tab-delimited file\nsubject_info &lt;- read.delim(\"subject_data.txt\", header = TRUE, stringsAsFactors = FALSE)\n\nhead(subject_info)\nstr(subject_info)\nread.delim() is just a wrapper around read.table(file, sep = \"\\\\t\", ...) where \\\\t represents a tab character.\nTry It Yourself:\n\nCreate a small text file on your computer (using a text editor like Notepad, TextEdit, or RStudio’s editor) with some physiological data, perhaps including time, heart rate, and blood pressure, separated by commas. Save it as my_exercise_data.csv in a specific folder.\nIn RStudio, set your working directory to that folder using setwd() or the RStudio menus.\nUse read.csv() to import the data into a data frame in R.\nUse head() and summary() to inspect the imported data frame.\n\n\n\n\n\n\n\nR Tip\n\n\n\nWhile base R functions like read.csv() and read.delim() are perfectly functional, the readr package (part of the tidyverse suite) offers faster and more consistent functions like read_csv() and read_delim(). If you work with very large datasets frequently, exploring readr is worthwhile, but the base R functions are sufficient for learning the core concepts.\n\n\nImporting Data from Excel Files (.xls, .xlsx)\nExcel files are ubiquitous in research labs. While not a plain text format, you can still import data directly from Excel files into R, although it requires installing and loading an additional package. The readxl package is a popular and reliable choice.\n\nInstall and Load the readxl package: You only need to install a package once on your computer. You need to load it into each R session where you want to use it.\n\ninstall.packages(\"readxl\") # Install the package (only need to do this once)\nlibrary(readxl) # Load the package into the current R session (do this every time you start a new session and want to use the package)\n\nRead the Excel file: Use the read_excel() function from the readxl package.\n\n# Assuming you have a file named \"experimental_results.xlsx\" in your working directory\n# and the data is on the first sheet.\nexperimental_data &lt;- read_excel(\"experimental_results.xlsx\")\nIf your data is on a specific sheet within the Excel file, you can specify the sheet name or number using the sheet argument:\n# Read data from the sheet named \"Subject 1 Data\"\nsubject1_data &lt;- read_excel(\"experimental_results.xlsx\", sheet = \"Subject 1 Data\")\n\n# Read data from the second sheet\nsubject2_data &lt;- read_excel(\"experimental_results.xlsx\", sheet = 2)\nLike with text file import, always inspect your data after importing using functions like head(), summary(), and str().\nTry It Yourself:\n\nIf you have Excel installed, create a simple spreadsheet with physiological data across a few columns. Save it as an .xlsx file in your working directory.\nInstall and load the readxl package.\nUse read_excel() to import your data into an R data frame.\nInspect the imported data frame.\n\n\n\n2.4.3 Exporting Data from R\nJust as you can import data into R, you can also export data frames (like the results of your model simulations) to files that can be opened in spreadsheet programs or shared with colleagues.\n1. Exporting to CSV (.csv)\nUse the write.csv() function to save a data frame to a CSV file.\n# Assuming 'simulation_output' is a data frame containing your model results\n# from a simulation run.\n\nwrite.csv(simulation_output, \"my_simulation_results.csv\")\nBy default, write.csv() includes row names in the output file. Usually, you don’t want these automatically generated row numbers from R in your exported data. To prevent this, use the argument row.names = FALSE:\nwrite.csv(simulation_output, \"my_simulation_results_no_rownames.csv\", row.names = FALSE)\n2. Exporting to Tab-Delimited Text (.txt)\nUse the write.table() function and specify the tab separator (sep=\"\\t\") to save a data frame to a tab-delimited file.\n# Export the simulation results to a tab-delimited file\nwrite.table(simulation_output, \"my_simulation_results.txt\", sep = \"\\t\", row.names = FALSE)\nTry It Yourself:\n\nCreate a small data frame directly in R (like the exercise_data example from the previous section).\nUse write.csv() to save this data frame to a CSV file in your working directory. Open the file in a text editor or spreadsheet program to verify it saved correctly.\nUse write.table() to save the same data frame to a .txt file. Open it to verify the tab separation.\n\nBeing able to import and export data is a fundamental skill for using R in research. Importing allows you to bring your experimental physiological data into R data frames, which you can then use for analysis, visualization, and crucially, comparison with your model simulations later on. Exporting allows you to save the output of your models or any processed data frames. With the ability to handle single values, vectors, data frames, and import/export files, you have the basic data manipulation skills needed to start working with R in a research context.\nIn the next section, we’ll build on this by learning how to create plots – the essential step for visualizing your data and your model’s dynamic outputs.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A Gentle Introduction to R for Modelers</span>"
    ]
  },
  {
    "objectID": "02-a_gentle_introduction_to_r_for_modelers.html#basic-plotting-in-r",
    "href": "02-a_gentle_introduction_to_r_for_modelers.html#basic-plotting-in-r",
    "title": "2  A Gentle Introduction to R for Modelers",
    "section": "2.5 Basic plotting in R",
    "text": "2.5 Basic plotting in R\nWe’ve covered the basics of R syntax, handling different data types, working with fundamental data structures like vectors and data frames, and importing/exporting your physiological data. Now, we arrive at a critically important aspect of using R for physiological modeling: visualization.\nAs we discussed in Chapter 1, physiological systems are dynamic, and their behavior unfolds over time. Whether you are analyzing experimental data (like heart rate changes during exercise) or examining the output of a mathematical model simulation (the predicted time course of a variable), seeing the data as a graph is infinitely more informative than looking at a table of numbers. Visualization allows us to quickly grasp trends, patterns, magnitudes of change, and relationships between variables. For dynamic models, plotting the predicted time series is how we actually see the dynamics that the differential equations describe. It’s how we understand what our model is telling us.\nR has excellent capabilities for creating graphs. There are two primary systems for plotting in R: Base R Graphics and the ggplot2 package.\n\nBase R Graphics: This system is built into R and provides functions like plot(), lines(), points(), etc. It’s great for quick, straightforward plots.\nggplot2: This is a very popular and powerful package based on the “grammar of graphics”, which provides a more structured and flexible way to build plots layer by layer. It excels at creating complex, publication-quality graphics and works seamlessly with data frames.\n\nWhile Base R graphics are useful for rapid exploratory plotting, we will primarily focus on ggplot2 in this book. This is because ggplot2 is particularly well-suited for handling data in data frames (which is how our model outputs from deSolve will be structured) and offers superior control and flexibility for creating the clear, informative plots necessary for presenting research findings and comparing models to data.\nLet’s briefly look at a simple Base R plot, and then we’ll dive into the power of ggplot2.\n\n2.5.1 A Glimpse of Base R Plotting\nUsing Base R graphics, you can create a simple scatter plot or line plot directly from vectors. Let’s use our time_points_min and heart_rates vectors from the previous section:\n\n# Create a simple scatter plot\nplot(time_points_min, heart_rates,\n     xlab = \"Time (minutes)\", # Label for the x-axis\n     ylab = \"Heart Rate (bpm)\", # Label for the y-axis\n     main = \"Heart Rate During Exercise\", # Plot title\n     pch = 16) # Set the plotting symbol to a solid circle\n\n# Add a line connecting the points\nlines(time_points_min, heart_rates, col = \"blue\", lwd = 2) # col for color, lwd for line width\n\n\n\n\n\n\n\n\nThis code would generate a scatter plot with points and then overlay a blue line connecting them, creating a basic time series graph. You can see it’s relatively straightforward for simple plots.\n\n\n2.5.2 Introducing ggplot2: Building Plots Layer by Layer\nggplot2 takes a different approach. It’s based on the idea that any plot can be built by combining different components or layers. The key components are:\n\nData: The data set containing the variables you want to plot (usually a data frame).\nAesthetic Mappings (aes()): How variables in your data are mapped to visual properties of the plot, such as their position on the x and y axes, color, size, shape, or transparency.\nGeometric Objects (geom_ functions): The visual elements used to represent the data, such as points (geom_point), lines (geom_line), bars (geom_bar), histograms (geom_histogram), etc.\nFaceting (Optional): Splitting the plot into multiple panels based on the levels of one or more categorical variables (useful for showing data from different subjects or groups).\nStatistical Transformations (Optional): Performing statistical summaries (like calculating means or smoothing lines) before plotting.\nScales (Optional): Controlling the mapping from data values to aesthetic values (e.g., setting the range of the axes, choosing colors).\nCoordinate Systems (Optional): The system used to map positions (e.g., Cartesian, polar).\nThemes (Optional): Controlling the overall appearance of the plot (fonts, background color, grid lines).\n\nYou build a ggplot2 plot by starting with the ggplot() function, adding layers using the + operator.\nFirst, you need to install and load the ggplot2 package (just like readxl). You only install it once, but you load it in every R session where you want to use it.\ninstall.packages(\"ggplot2\") # Install the package (if you haven't already)\n\nlibrary(ggplot2) # Load the package for this session\n\nNow, let’s recreate our exercise heart rate plot using ggplot2. We’ll use the exercise_data data frame we created earlier, which contains Time and HeartRate columns.\n\n# Start the plot: specify data frame and map Time to x and HeartRate to y\nggplot(data = exercise_data, aes(x = Time, y = HeartRate)) +\n  geom_point() + # Add a layer of points\n  geom_line()    # Add a layer of lines\n\n\n\n\n\n\n\n\nLet’s break this down:\n\nggplot(data = exercise_data, aes(x = Time, y = HeartRate)): This is the base layer. We tell ggplot to use exercise_data as the source of data. Inside aes(), we define the aesthetic mapping: map the Time column to the x-axis position and the HeartRate column to the y-axis position.\n+: This operator is used to add layers or customize elements to the plot object created by the previous line.\ngeom_point(): This layer tells ggplot to draw points for each data point, using the x and y positions defined in the aes() mapping.\ngeom_line(): This layer tells ggplot to draw lines connecting the points, again using the x and y positions.\n\nRunning this code will produce a plot in the Plots pane. Notice that ggplot2 automatically adds axis labels based on the variable names and creates a simple background.\n\n\n2.5.3 Customizing Your ggplot2 Plots**\nTo make your plots informative and ready for presentation, you’ll need to customize them. Here are some common customizations:\n1. Adding Labels and Title:\nUse the labs() function to add a title, subtitles, captions, and customize axis labels or the titles of legends (for colors, shapes, etc.).\n\nggplot(data = exercise_data, aes(x = Time, y = HeartRate)) +\n  geom_point() +\n  geom_line() +\n  labs(title = \"Heart Rate Response During Moderate Exercise\",\n       x = \"Time (minutes)\",\n       y = \"Heart Rate (beats/min)\")\n\n\n\n\n\n\n\n\n2. Changing Appearance (Color, Size, Line Type, Shape):\nYou can set fixed aesthetic properties outside the aes() function within a geom_ function, or map these properties to variables inside aes().\n\nSetting Fixed Appearance:\n\nggplot(data = exercise_data, aes(x = Time, y = HeartRate)) +\n  geom_point(color = \"red\", size = 3) + # Set point color to red, size to 3\n  geom_line(linetype = \"dashed\", color = \"blue\", linewidth = 1) + # Dashed blue line, width 1\n  labs(title = \"Heart Rate Response During Moderate Exercise\",\n       x = \"Time (minutes)\",\n       y = \"Heart Rate (beats/min)\")\n\n\n\n\n\n\n\n\nYou can use color names (like \"red\", \"blue\", \"grey\") or hexadecimal color codes (like \" #FF0000\" for red). linetype can be \"solid\", \"dashed\", \"dotted\", etc. size for points, linewidth for lines.\nMapping Appearance to Variables: This is powerful for showing relationships or distinguishing groups/variables on the same plot.\nImagine your data frame had a column indicating if the subject is “Trained” or “Untrained”, or if the measurement was “Simulation” vs “Experimental Data”. You could map this column to color.\nTo plot multiple variables (like Heart Rate and Absolute Blood Pressure) against Time on the same graph with different colors/lines using ggplot2, it’s best practice to first reshape your data frame into a “long” format. This means instead of having separate columns for HeartRate and AbsoluteBP, you’d have one column for Value and another column indicating the Variable (e.g., “HeartRate” or “AbsoluteBP”). The tidyr package (another tidyverse package) is excellent for this, specifically the pivot_longer() function.\n\n# Install and load tidyr if you haven't\n# install.packages(\"tidyr\")\nlibrary(tidyr)\n\n# Reshape the data frame to long format for plotting multiple variables\n# Exclude Subject and HRR_percent for this example plot\nexercise_data_long &lt;- pivot_longer(exercise_data,\n                                   cols = c(HeartRate, AbsoluteBP), # Columns to pivot\n                                   names_to = \"Physiological_Variable\", # New column for variable names\n                                   values_to = \"Value\") # New column for values\n\nhead(exercise_data_long) # See the new structure\n\n# A tibble: 6 × 6\n   Time DeltaBP Subject HRR_percent Physiological_Variable Value\n  &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt;\n1     0       0 A              0    HeartRate                 60\n2     0       0 A              0    AbsoluteBP                80\n3     1       5 A              9.23 HeartRate                 72\n4     1       5 A              9.23 AbsoluteBP                85\n5     2      10 A             26.9  HeartRate                 95\n6     2      10 A             26.9  AbsoluteBP                90\n\n\nNow, plot the Value against Time, mapping Physiological_Variable to color:\n\nggplot(data = exercise_data_long, aes(x = Time, y = Value, color = Physiological_Variable)) +\n  geom_line() +\n  geom_point() +\n  labs(title = \"Dynamic Physiological Response During Exercise\",\n       x = \"Time (minutes)\",\n       y = \"Value\",\n       color = \"Variable\") # Customize the legend title\n\n\n\n\n\n\n\n\nggplot2 automatically assigns a different color (and creates a legend) for each unique value in the Physiological_Variable column (“HeartRate”, “AbsoluteBP”). This is incredibly powerful for visualizing and comparing different time series, including later when you plot simulated vs. experimental data.\n\n3. Themes for Appearance:\nggplot2 themes control non-data plot elements like background color, grid lines, font styles, etc. theme_minimal(), theme_bw(), and theme_classic() are popular choices for a cleaner look than the default grey background. Add them as a layer:\n\nggplot(data = exercise_data_long, aes(x = Time, y = Value, color = Physiological_Variable)) +\n  geom_line() +\n  geom_point() +\n  labs(title = \"Dynamic Physiological Response During Exercise\",\n       x = \"Time (minutes)\",\n       y = \"Value\",\n       color = \"Variable\") +\n  theme_bw() # Apply a black and white theme\n\n\n\n\n\n\n\n\n4. Saving Your Plots\nOnce you’ve created a plot you’re happy with, you can save it to a file (like PNG, JPEG, PDF, TIFF) using the ggsave() function. It saves the last plot displayed by default.\n# Save the last plot to a PNG file\nggsave(\"physiological_response_plot.png\", width = 6, height = 4, units = \"in\")\n\n# Save to a PDF\nggsave(\"physiological_response_plot.pdf\", width = 6, height = 4, units = \"in\")\nYou can specify the filename, directory (if not the working directory), dimensions (width, height), and units (units = \"in\", \"cm\", or \"mm\").\nTry It Yourself:\n\nUsing the exercise_data data frame (or your own imported data frame):\nUse ggplot2 to create a scatter plot of DeltaBP vs. Time. Add points and lines.\nAdd a title and axis labels to the plot.\nReshape the data frame to include HeartRate, DeltaBP, and AbsoluteBP in the long format.\nCreate a single plot showing the time courses of HeartRate, DeltaBP, and AbsoluteBP on the same graph, colored by variable. Add appropriate labels and a title. Apply a theme like theme_classic().\nSave one of your plots as a PNG file.\n\nVisualization is paramount for understanding dynamic physiological data and the output of our models. While Base R graphics offer a quick plotting option, ggplot2 provides a powerful, flexible, and systematic way to create high-quality plots, especially when working with data frames containing multiple variables or simulation results. By understanding the fundamental concepts of ggplot2 – mapping data to aesthetics within aes() and adding visual layers with geom_ functions – and learning how to customize labels, colors, and line types, you have gained the essential skills to visualize both your experimental data and the dynamic predictions from your physiological models. This ability to see and interpret the dynamic behavior is a cornerstone of using differential equations for physiological insight.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A Gentle Introduction to R for Modelers</span>"
    ]
  },
  {
    "objectID": "02-a_gentle_introduction_to_r_for_modelers.html#writing-simple-r-functions",
    "href": "02-a_gentle_introduction_to_r_for_modelers.html#writing-simple-r-functions",
    "title": "2  A Gentle Introduction to R for Modelers",
    "section": "2.6 Writing simple R functions",
    "text": "2.6 Writing simple R functions\nWe’ve learned how to perform calculations, store values in variables, work with collections of data in vectors and data frames, and create basic plots. These are fundamental building blocks in R. Now, let’s introduce another powerful concept that is absolutely crucial for building dynamic models in R: functions.\nYou’ve already used many built-in R functions, like c(), length(), mean(), sqrt(), ggplot(), and read.csv(). A function is simply a reusable block of code designed to perform a specific task. It takes inputs (called arguments), performs some operations using those inputs, and then returns an output.\n\n2.6.1 Why Write Your Own Functions?\nWhy would you bother writing your own functions when R has so many built-in ones?\n\nAvoid Repetition (DRY - Don’t Repeat Yourself): If you find yourself performing the same sequence of calculations or operations multiple times in your script, putting that code into a function allows you to write it once and call it whenever you need it. This makes your code shorter, cleaner, and easier to read.\nOrganization: Functions break down complex tasks into smaller, manageable pieces. This makes your scripts easier to understand, debug, and maintain.\nReusability: Once you’ve written a function, you can reuse it in different parts of the same script, in entirely different scripts, or even share it with colleagues.\nReadability: Giving a block of code a descriptive function name makes its purpose clear. calculate_bmi(mass_kg, height_m) is much more immediately understandable than a raw calculation mass_kg / height_m^2 buried in a script.\nMaintainability and Debugging: If you need to fix a bug or modify how a specific task is performed, you only need to do it in one place (the function definition) rather than finding and changing every instance of repeated code.\n\nConsider calculating Body Mass Index (BMI). The formula is BMI = mass (kg) / height (m)\\(^2\\). If you had data for 50 subjects, you wouldn’t want to type subject1_mass / subject1_height^2, subject2_mass / subject2_height^2, etc., 50 times. A function is the perfect solution.\n\n\n2.6.2 How to Define a Simple R Function\nYou define a function in R using the function() keyword and the assignment operator (&lt;-). The basic syntax looks like this:\nfunction_name &lt;- function(argument1, argument2, ...) {\n  # Code that performs the task\n  # This code uses the arguments (input values)\n  # ...\n  return(output_value) # Specify what the function should output\n}\nLet’s break down the components:\n\nfunction_name: This is the name you give your function (follow the same naming rules as variables). Choose a name that clearly describes what the function does.\n&lt;-: The assignment operator, used to store the function definition in the variable function_name.\nfunction(...): This keyword tells R you are defining a function. The parentheses () contain the names of the arguments (inputs) the function accepts. These names are like temporary variables that will hold the values passed into the function when you call it. You can have zero or more arguments, separated by commas.\n{ ... }: The curly braces enclose the body of the function. This is where you write the R code that performs the function’s task. This code can use the argument names as variables.\nreturn(output_value): This statement specifies the value that the function should output or return. Once R encounters a return() statement, the function stops executing and gives back the specified value. If you omit return(), R will return the result of the last evaluated expression in the function body. Using return() explicitly is often good practice for clarity.\n\nExample 1: BMI Calculator Function\nLet’s write that BMI function:\n\n# Define the function named calculate_bmi\ncalculate_bmi &lt;- function(mass_kg, height_m) {\n  # Function body: Calculate BMI\n  bmi_value &lt;- mass_kg / height_m^2\n\n  # Return the calculated BMI value\n  return(bmi_value)\n}\n\nTo make this function available in your R session, you need to run the code that defines it (either type it directly into the Console and press Enter, or, preferably, type it in your script editor and run the lines using Ctrl/Cmd + Enter). Once it’s run, the function calculate_bmi will appear in your Environment pane.\nNow you can call the function by typing its name followed by parentheses containing the values you want to use for the arguments, in the correct order:\n\n# Calculate BMI for someone 70kg and 1.75m\nbmi_subject1 &lt;- calculate_bmi(70, 1.75)\nbmi_subject1\n\n[1] 22.85714\n\n# Calculate BMI for someone 85kg and 1.80m\nbmi_subject2 &lt;- calculate_bmi(85, 1.80)\nbmi_subject2\n\n[1] 26.23457\n\n\nYou can also pass variables as arguments:\n\nsubject3_mass &lt;- 75\n\nsubject3_height &lt;- 1.68\n\nbmi_subject3 &lt;- calculate_bmi(subject3_mass, subject3_height)\n\nbmi_subject3\n\n[1] 26.57313\n\n\nThe function makes the calculation reusable and easy to read.\nExample 2: VO2 Conversion Function\nLet’s create a function to convert VO2 from ml/kg/min to L/min, which might be a common calculation in your analysis:\n\n# Define the function\nconvert_vo2_mlkgmin_to_lmin &lt;- function(vo2_ml_kg_min, body_weight_kg) {\n  # Calculate total VO2 in ml/min\n  vo2_ml_min &lt;- vo2_ml_kg_min * body_weight_kg\n\n  # Convert ml/min to L/min\n  vo2_l_min &lt;- vo2_ml_min / 1000\n\n  # Return the value in L/min\n  return(vo2_l_min)\n}\n\n# Use the function\nvo2_l_min_subjectA &lt;- convert_vo2_mlkgmin_to_lmin(vo2_ml_kg_min = 50, body_weight_kg = 70)\n\nvo2_l_min_subjectA\n\n[1] 3.5\n\n\nNotice that when calling the function, I used argument_name = value. This makes the code easier to read and allows you to provide arguments out of order (though it’s good practice to stick to the order if you know it).\nTry It Yourself:\nWrite a function called calculate_hr_reserve_percent that takes three arguments: current_hr, resting_hr, and max_hr. The function should calculate the heart rate reserve percentage using the formula: ((current_hr - resting_hr) / (max_hr - resting_hr)) * 100. Test your function with some values.\n\n\n2.6.3 Functions for Modeling: Calculating Rates of Change\nNow, let’s connect this to differential equations. As we discussed, a differential equation model describes the rate of change of variables based on their current state and model parameters. When we use R packages like deSolve to solve these equations numerically, we need to provide the solver with an R function that can calculate these rates of change.\nThis function will have a specific structure required by the solver, but conceptually, it does exactly what we described: it takes the current values of the state variables and parameters as input and returns the calculated instantaneous rates of change for each variable.\nLet’s revisit the simple drug clearance example: \\(\\frac{dC}{dt} = -kC\\). We need a function that, given the current concentration (\\(C\\)) and the parameter (\\(k\\)), calculates the rate of change of \\(C\\).\nIn R, this function might look conceptually like this (the actual structure for deSolve is slightly different, but this illustrates the idea):\n\n# A function to calculate the rate of change for the drug concentration\ncalculate_clearance_rate &lt;- function(current_concentration, clearance_rate_constant) {\n  # Calculate the rate of change (dC/dt)\n  dC_dt &lt;- -clearance_rate_constant * current_concentration\n\n  # The function needs to return this rate of change\n  return(dC_dt)\n}\n\n# Example: If concentration is 50 and k is 0.1, what's the rate of change?\nrate_now &lt;- calculate_clearance_rate(current_concentration = 50, clearance_rate_constant = 0.1)\nrate_now\n\n[1] -5\n\n\n(Note: -5 means that concentration is decreasing at a rate of 5 units per unit of time.)\nThis calculate_clearance_rate function embodies the differential equation \\(\\frac{dC}{dt} = -kC\\). It takes the necessary inputs (the current state variable current_concentration and the parameter clearance_rate_constant) and calculates the instantaneous dC_dt.\nWhen you use deSolve to solve the differential equation, you will provide a function just like this (with a specific format required by deSolve). The solver will repeatedly call this function, giving it the current state of the variables, and use the returned rates of change to figure out the state at the next tiny step in time.\nWriting functions in R is a fundamental skill that makes your code efficient, organized, and reusable. More importantly for this book, defining functions that calculate the rates of change of your physiological variables is the core step in translating your mathematical model (the differential equations) into R code that the numerical solver can understand. As we move into Chapters 3 and 4, we will formalize the idea of rates of change and build simple models. Then, in Part 2, you will see exactly how to package these rate equations into R functions for use with the deSolve package, bringing your physiological blueprints to life as dynamic simulations.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A Gentle Introduction to R for Modelers</span>"
    ]
  },
  {
    "objectID": "02-a_gentle_introduction_to_r_for_modelers.html#introduction-to-r-packages-relevant-for-modeling",
    "href": "02-a_gentle_introduction_to_r_for_modelers.html#introduction-to-r-packages-relevant-for-modeling",
    "title": "2  A Gentle Introduction to R for Modelers",
    "section": "2.7 Introduction to R packages relevant for modeling",
    "text": "2.7 Introduction to R packages relevant for modeling\nThroughout this chapter, we’ve built a foundation in R, covering basic syntax, data types, handling collections of data in vectors and data frames, importing/exporting files, and writing simple functions. You now have the essential building blocks of the R language. However, the true power of R, especially for specialized tasks like solving differential equations and creating advanced visualizations, comes from its vast ecosystem of packages.\nThink of R itself as the core operating system – it provides the fundamentals. R packages are like applications or software extensions that you can install to add specialized capabilities. They are collections of functions, data sets, and documentation contributed by the R community. For physiological modeling, we will rely heavily on a few key packages that provide the sophisticated tools we need.\n\n2.7.1 What are R Packages and Why Use Them?\nA package in R is essentially a bundle of code, documentation, and sometimes data, that extends the functionality of base R. When you install R, you get the base installation with fundamental functions for statistics, data manipulation, and basic plotting. However, for almost any specialized task – whether it’s advanced statistical modeling, geographic information systems, bioinformatics, or solving differential equations – you will need to install and use packages.\nWhy are packages so important for dynamic modeling?\n\nAccess to Specialized Algorithms: Solving differential equations numerically requires complex algorithms that have been developed and refined over many years. Packages like deSolve provide access to highly efficient and reliable implementations of these algorithms, saving us from having to code them from scratch (a task requiring significant expertise in numerical analysis).\nStreamlined Workflows: Packages often bundle related functions together, providing a coherent set of tools for a specific task (like plotting with ggplot2). This streamlines your workflow and makes complex tasks more manageable.\nLeveraging Community Expertise: Packages are often developed by experts in specific fields. By using a package, you are leveraging their expertise and benefiting from tested and documented code.\nAccess to Advanced Visualization: While base R can plot, packages like ggplot2 offer much greater flexibility and control over plot aesthetics, allowing you to create the clear, customized, publication-quality graphics necessary to understand and present complex model outputs and compare them effectively with experimental data.\n\nFinding packages is typically done through the Comprehensive R Archive Network (CRAN), which is the primary repository for R packages. When a package is accepted on CRAN, it has met certain quality standards.\n\n\n2.7.2 Installing and Loading Packages\nUsing a package is a two-step process:\n\nInstallation: You download the package files from a repository (like CRAN) and install them onto your computer. This only needs to be done once for a given version of R on your machine. You use the install.packages() function for this. The package name must be in quotes.\n# Install the deSolve package\ninstall.packages(\"deSolve\")\n\n# Install the ggplot2 package\ninstall.packages(\"ggplot2\")\n\n# You can install multiple packages at once using a vector of names\ninstall.packages(c(\"deSolve\", \"ggplot2\", \"tidyr\")) # tidyr is useful for plotting!\nWhen you run install.packages(), R might ask you to choose a CRAN mirror (a server location). Choose one that is geographically close to you.\nLoading (Attaching): After installation, the package files are on your computer, but their functions are not automatically available in your R session when you start RStudio. You need to load or attach the package to make its functions accessible in the current session. You do this using the library() function. The package name does not need to be in quotes here, although it works if you include them.\n# Load the deSolve package for the current session\nlibrary(deSolve)\n\n# Load the ggplot2 package\nlibrary(ggplot2)\n\n# Load the tidyr package\nlibrary(tidyr)\nYou need to run library() for each package you want to use every time you start a new R session. It’s common practice to put library() calls for all the packages your script uses at the very beginning of the script.\nR Tip: RStudio has a convenient “Packages” tab in the bottom-right pane. You can see installed packages there, and check/uncheck boxes to load/unload them without typing the library() command. However, typing library() in your script is better for reproducibility, as anyone running your script will automatically load the necessary packages (assuming they are installed).\n\n\n\n2.7.3 Getting Help for Packages\nJust like with base R functions, you can get help for packages and their functions:\n\nTo see a list of functions and documentation for an installed package, you can use help(package = \"package_name\").\nTo get help for a specific function within a package (e.g., the ode function in deSolve), use the standard ? syntax: ?ode. If a function name exists in multiple packages, you can specify the package explicitly using package_name::function_name, e.g., ?deSolve::ode.\n\n\n\n2.7.4 Key Packages for Physiological Modeling in this Book\nTwo packages will be central to our work in this book:\nThe deSolve Package: Your ODE Solver\n\nWhat it does: The deSolve package provides a comprehensive suite of numerical solvers for initial value problems of ordinary differential equations (ODEs), as well as other types of differential equations. This is the engine that will take your mathematical model (defined as an R function calculating rates of change) and simulate its behavior over time.\nWhy it’s important for modeling: As discussed in Chapter 1, analytical solutions for physiological ODE models are rare. deSolve implements robust numerical methods that can handle the complexities of realistic biological systems, including non-linearities and “stiff” systems (which are common in biology and require specialized solvers).\nKey Function (ode): The primary function we will use from deSolve is ode(). In Chapter 5, we will delve into the details of how to use ode(), but conceptually, it takes:\n\nA function that defines your physiological model (i.e., calculates the rates of change, like the calculate_clearance_rate function idea from the previous section, but in a format deSolve expects).\nThe initial values of your state variables (e.g., initial heart rate, initial hormone concentration).\nThe time points at which you want the solution (e.g., every second for 10 minutes).\nAny parameters your model needs (e.g., rate constants, sensitivities).\nIt then returns a data frame containing the time points and the corresponding simulated values of all your state variables.\n\nConnecting to the Blueprint: If your physiological understanding is the conceptual blueprint and the differential equations are the detailed drawings, deSolve is the simulation engine that builds the dynamic structure from those drawings, showing you how it behaves over time.\n\nWe will dedicate Chapter 5 entirely to understanding and using the deSolve package to solve ODE models.\nThe ggplot2 Package: Your Visualization Powerhouse\n\nWhat it does: The ggplot2 package is arguably the most popular package for creating graphics in R. It provides a flexible and elegant system for building plots layer by layer, based on the “grammar of graphics”.\nWhy it’s important for modeling: As we emphasized earlier, visualization is key to understanding dynamic models. ggplot2 allows us to create informative time series plots of our simulated model outputs, compare multiple simulation runs, and overlay experimental data points on top of model predictions. Its consistent syntax and powerful customization options make it ideal for creating the clear, publication-quality figures needed to communicate modeling results. Since deSolve output is a data frame, ggplot2, which works seamlessly with data frames, is the perfect companion.\nKey Function (ggplot): The core function is ggplot(), which initializes a plot and specifies the data and aesthetic mappings. As we saw in the previous section, you add layers like points (geom_point()) and lines (geom_line()) using the + operator.\nConnecting to the Blueprint: If deSolve runs the simulation, ggplot2 is the tool that lets you visually inspect the output, like watching the simulated heart rate trace change over time or comparing it side-by-side with your experimental data points.\n\nWe will revisit ggplot2 in Chapter 7 and subsequent chapters, applying its capabilities specifically to visualizing the dynamic outputs of our physiological models.\nOther Relevant Packages\nWhile deSolve and ggplot2 are the stars of the show for core modeling and visualization, you might encounter or find useful other packages:\n\ntidyr: (already introduced briefly) Useful for tidying and reshaping data frames, including getting data into the “long” format often best for ggplot2.\ndplyr: Provides a powerful and consistent set of functions for data manipulation (filtering, selecting, arranging, summarizing data frames). Excellent for preparing experimental data before comparing it to models.\nPackages for Parameter Estimation: If you move towards statistically fitting model parameters to data, you might use built-in functions like optim or packages specifically designed for model fitting in a biological context, but that’s beyond the scope of introductory modeling.\n\nR packages are essential extensions that add specialized functionality to R. For physiological modeling with differential equations, the deSolve package provides the crucial tools for numerically solving the equations and simulating dynamic behavior, while the ggplot2 package provides the powerful capabilities needed to visualize the resulting time series and compare them with experimental data. You now know how to install and load these (and other) packages, making their functions available for use.\nWith the R basics covered in this chapter – setting up R/RStudio, basic syntax, data structures, importing/exporting, writing functions, and using packages – you have the fundamental computational skills needed. In the next chapter, we will return to the mathematical side, delving deeper into the concept of rates of change, preparing us to truly start building and solving physiological differential equation models in R in the chapters that follow.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A Gentle Introduction to R for Modelers</span>"
    ]
  },
  {
    "objectID": "03-thinking_dynamically_rates_of_change.html",
    "href": "03-thinking_dynamically_rates_of_change.html",
    "title": "3  Thinking Dynamically: Rates of Change",
    "section": "",
    "text": "3.1 Introduction to the Concept of Rates of Change\nWelcome to Chapter 3! In Chapter 1, we made the case that physiology is fundamentally dynamic – a science of processes changing over time. We introduced the idea that differential equations are the natural language for describing these time-dependent phenomena. Chapter 2 equipped us with the essential R skills to work with data and visualize relationships over time. Now, in Chapter 3, we return to the mathematical side to explore the core concept that underpins differential equations: the rate of change.\nUnderstanding rates of change is intuitive for physiologists because it’s something we deal with constantly. We measure how quickly a variable goes up or down in response to a stimulus, how fast a substance is metabolized, or the speed at which a signal propagates. All these describe a rate of change. Differential equations are simply a formal way to express the rules governing these rates.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Thinking Dynamically: Rates of Change</span>"
    ]
  },
  {
    "objectID": "03-thinking_dynamically_rates_of_change.html#introduction-to-the-concept-of-rates-of-change",
    "href": "03-thinking_dynamically_rates_of_change.html#introduction-to-the-concept-of-rates-of-change",
    "title": "3  Thinking Dynamically: Rates of Change",
    "section": "",
    "text": "3.1.1 What is a Rate of Change?\nAt its most basic level, a rate of change tells us how much a quantity changes over a specific period.\nLet’s consider a physiological variable, let’s call it \\(X\\), which changes over time, \\(t\\). For instance, \\(X\\) could be Heart Rate (HR) in beats per minute, and \\(t\\) could be time in seconds or minutes.\nIf we measure \\(X\\) at two different times, \\(t_1\\) and \\(t_2\\), we get values \\(X_1\\) and \\(X_2\\).\n\nThe change in \\(X\\) is \\(\\Delta X = X_2 - X_1\\).\nThe change in time is \\(\\Delta t = t_2 - t_1\\).\n\nThe average rate of change of \\(X\\) over the time interval from \\(t_1\\) to \\(t_2\\) is simply the total change in \\(X\\) divided by the duration of the time interval:\n\\[\\text{Average Rate of Change} = \\frac{\\Delta X}{\\Delta t} = \\frac{X_2 - X_1}{t_2 - t_1}\\]\nLet’s use a physiological example: Heart Rate during the first minute of exercise.\n\nSuppose at \\(t_1 = 0\\) minutes (exercise onset), HR is \\(X_1 = 60\\) bpm.\nSuppose at \\(t_2 = 1\\) minute, HR is \\(X_2 = 90\\) bpm.\n\nThe change in HR is \\(\\Delta HR = 90 - 60 = 30\\) bpm. The change in time is \\(\\Delta t = 1 - 0 = 1\\) minute.\nThe average rate of change of HR during the first minute is:\n\\[\n\\frac{\\Delta HR}{\\Delta t} = \\frac{30 \\text{ bpm}}{1 \\text{ minute}} = 30 \\text{ bpm/minute}\n\\]\nThis tells us that, on average, Heart Rate increased by 30 beats per minute during that first minute of exercise.\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nCalculating average rates of change is common in exercise physiology – for instance, looking at the average rate of decline in heart rate over the first 60 seconds of recovery. It gives a useful overall measure of how quickly something changed across a period.\n\n\n\n\n3.1.2 From Average to Instantaneous Rate of Change\nWhile the average rate is informative over an interval, physiological processes are continuous and their speed of change can vary from moment to moment. In the example above, Heart Rate probably didn’t increase by exactly 30 bpm every minute throughout that first minute. It might have increased faster initially and then started to slow down slightly as it approached the rate needed for the exercise intensity.\nSometimes, we need to know how fast a physiological variable is changing at a specific instant in time. This is the concept of the instantaneous rate of change.\nImagine plotting the Heart Rate data from the previous example on a graph, like the time series plots we learned to create in Chapter 2. The average rate of change over the first minute is represented by the slope of the straight line connecting the point at \\(t=0\\) to the point at \\(t=1\\).\nNow, imagine measuring Heart Rate every 30 seconds, then every 10 seconds, then every 1 second, then every tenth of a second. As the time interval (\\(\\Delta t\\)) between our measurements gets smaller and smaller, the average rate of change (\\(\\frac{\\Delta X}{\\Delta t}\\)) calculated over that shrinking interval gets closer and closer to the true rate of change at a single point in time.\nThe instantaneous rate of change is what the average rate of change approaches as the time interval \\(\\Delta t\\) approaches zero.\nIn mathematical notation, we represent the instantaneous rate of change of \\(X\\) with respect to \\(t\\) as \\(\\frac{dX}{dt}\\). You can read this as “dee X dee tee”, or “the rate of change of X with respect to time”. The notation \\(\\frac{d}{dt}\\) is called the derivative operator; it signifies finding the instantaneous rate of change of whatever follows it with respect to time.\nGraphically, the instantaneous rate of change of \\(X\\) at a specific time point \\(t\\) is represented by the slope of the line that is tangent to the curve of \\(X\\) versus \\(t\\) at that exact point.\n\nIf the tangent line is steep and pointing upwards, \\(\\frac{dX}{dt}\\) is large and positive (X is increasing rapidly). Think of HR right at the start of vigorous exercise.\nIf the tangent line is steep and pointing downwards, \\(\\frac{dX}{dt}\\) is large in magnitude but negative (X is decreasing rapidly). Think of HR right at the start of recovery from vigorous exercise.\nIf the tangent line is horizontal (flat), \\(\\frac{dX}{dt}\\) is zero (X is momentarily stable or at a peak/trough). Think of Heart Rate during steady-state exercise.\n\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nThe instantaneous rate of change (\\(dX/dt\\)) is often more relevant for understanding the moment-to-moment control of a physiological system. When we say that increased vagal tone rapidly decreases heart rate, we are describing a large, negative instantaneous rate of change of HR in response to a vagal stimulus. When sympathetic activation causes a slower but sustained increase in heart rate, we are describing a positive, perhaps initially smaller, instantaneous rate of change of HR compared to vagal withdrawal, but one that persists over time.\n\n\n\n\n3.1.3 Physiological Examples of Rates of Change (\\(dX/dt\\))\nMany core concepts in physiology are inherently described in terms of instantaneous rates of change:\n\nCardiac Output: The rate at which blood volume is pumped by the heart per unit time (e.g., L/min). This is literally a rate of change of blood volume in the circulatory system.\nOxygen Consumption (\\(\\dot{V}\\)O\\(_2\\)): The rate at which oxygen is utilized by the body (e.g., ml/min or L/min). The symbol \\(\\dot{V}\\) itself indicates a rate of volume change over time (the dot over the V is traditional notation for a time derivative). The kinetics of \\(\\dot{V}\\)O\\(_2\\) at the start of exercise describe its instantaneous rate of change as it rises to meet demand.\nSubstance Concentration: The rate at which the concentration of a substance changes in a compartment due to influx, efflux, production, or consumption. For a drug being cleared, the rate of change of concentration (\\(dC/dt\\)) is negative. For lactate production, the rate of change of lactate concentration (\\(dLactate/dt\\)) is positive during intense exercise.\nMuscle Force Development/Relaxation: The rate at which muscle force increases during contraction or decreases during relaxation.\nNerve Firing Rate: While often described in terms of frequency (spikes/second), the underlying membrane potential changes involve rates of ion flux. At a higher level, the rate of change of sympathetic or parasympathetic outflow can be thought of as a signal influencing the rate of change of target organs like the heart.\n\n\n\n3.1.4 Connecting Rates of Change to the System’s State\nThe crucial link that makes differential equations so powerful for modeling physiological systems is that the instantaneous rate of change of a variable is typically determined by the current state of the system.\n\nThe rate of change of blood flow is determined by the current pressure difference and vascular resistance.\nThe rate of change of reaction product concentration is determined by the current concentrations of reactants and enzyme activity.\nThe rate of change of heart rate is determined by the current balance of sympathetic and parasympathetic inputs acting on the SA node.\n\nThis is the core idea behind a differential equation: it is an equation that tells you how to calculate the rate of change (\\(dX/dt\\)) of a variable at any given moment, based on the values of the variables and parameters at that same moment.\nFor our heart rate case study, a simplified model might state that the rate of change of heart rate (\\(dHR/dt\\)) is the result of a positive drive from sympathetic tone (\\(S\\)) minus a negative drive from parasympathetic tone (\\(P\\)), potentially modulated by the current HR value itself or other factors. This gives us an equation like:\n\\[\n\\frac{dHR}{dt} = \\text{Influence of } S - \\text{Influence of } P + \\text{Other Factors}\n\\]\nThis equation explicitly tells us the instantaneous rate at which Heart Rate is changing (\\(dHR/dt\\)) based on the current values of \\(S\\) and \\(P\\).\nThe concept of a rate of change, particularly the instantaneous rate of change (\\(dX/dt\\)), is the cornerstone of dynamic modeling with differential equations. It allows us to quantify how quickly physiological variables are evolving at any given moment. Crucially, in biological systems, these instantaneous rates are typically determined by the current state of the system – the prevailing levels of other physiological variables and fixed parameters. Differential equations provide the mathematical framework to write down these rules for how rates of change are calculated. In the next sections, we will explore the relationship between discrete changes and continuous rates more formally and then begin the process of translating these ideas into simple differential equations that describe basic physiological processes, setting us up to build more complex dynamic blueprints later.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Thinking Dynamically: Rates of Change</span>"
    ]
  },
  {
    "objectID": "03-thinking_dynamically_rates_of_change.html#understanding-derivatives-in-a-physiological-context",
    "href": "03-thinking_dynamically_rates_of_change.html#understanding-derivatives-in-a-physiological-context",
    "title": "3  Thinking Dynamically: Rates of Change",
    "section": "3.2 Understanding Derivatives in a Physiological Context",
    "text": "3.2 Understanding Derivatives in a Physiological Context\nIn the previous section, we introduced the concept of a rate of change, moving from the familiar idea of an average change over an interval (\\(\\Delta X / \\Delta t\\)) to the more precise idea of an instantaneous rate of change at a single moment in time (\\(\\frac{dX}{dt}\\)). We stated that this instantaneous rate is what the average rate approaches as the time interval becomes infinitesimally small, and graphically, it represents the slope of the tangent line to a time series plot.\nNow, let’s formalize this a little further and spend more time understanding what this instantaneous rate of change, often called the derivative, tells us in a physiological context. While the mathematical definition of a derivative involves limits (the concept of \\(\\Delta t\\) going to zero), our focus is on the meaning and interpretation of the derivative as it applies to biological variables that change over time.\nThe derivative of a physiological variable \\(X\\) with respect to time \\(t\\), denoted \\(\\frac{dX}{dt}\\), is the quantitative measure of how fast and in what direction \\(X\\) is changing at a particular instant \\(t\\).\nThink of it like the speedometer in a car. If you calculate your average speed for a trip (total distance / total time), you get one number. But the speedometer tells you your instantaneous speed at any given moment – the rate at which your distance from the starting point is changing right now. If distance is \\(D\\) and time is \\(t\\), the speedometer reads \\(\\frac{dD}{dt}\\).\nIn physiology, the variables aren’t distance, but heart rate, concentration, force, volume, etc. The independent variable is almost always time \\(t\\). So, when we talk about “the derivative” of a physiological variable, we almost always mean its derivative with respect to time.\n\n3.2.1 Interpreting the Derivative \\(\\frac{dX}{dt}\\) in Physiological Terms\nThe value of the derivative \\(\\frac{dX}{dt}\\) at any given time \\(t\\) tells you two key things about the physiological variable \\(X\\):\n\nThe Direction of Change (Sign):\n\nIf \\(\\frac{dX}{dt} &gt; 0\\), the variable \\(X\\) is increasing at that instant.\nIf \\(\\frac{dX}{dt} &lt; 0\\), the variable \\(X\\) is decreasing at that instant.\nIf \\(\\frac{dX}{dt} = 0\\), the variable \\(X\\) is momentarily not changing; it could be at a steady state, a peak, or a trough.\n\nThe Speed (Magnitude):\n\nThe larger the absolute value of \\(\\frac{dX}{dt}\\) (written \\(|\\frac{dX}{dt}|\\)), the faster the variable \\(X\\) is changing at that instant.\nA large positive value means rapid increase.\nA large negative value means rapid decrease.\nA value close to zero (positive or negative) means slow change.\n\n\nThe units of \\(\\frac{dX}{dt}\\) are always the units of \\(X\\) divided by the units of \\(t\\). If \\(X\\) is measured in beats per minute (bpm) and \\(t\\) is measured in seconds (s), then \\(\\frac{dHR}{dt}\\) has units of bpm/s. If concentration \\(C\\) is in millimoles per liter (mmol/L) and time \\(t\\) is in minutes, then \\(\\frac{dC}{dt}\\) has units of mmol/L/min.\n\n\n3.2.2 Physiological Examples of Derivative Interpretation\nLet’s revisit some physiological scenarios and interpret what the derivative means:\nExample 1: Heart Rate Response to Exercise and Recovery\nImagine plotting Heart Rate (HR) in bpm versus Time (t) in minutes during a square-wave bout of moderate exercise (sudden onset, sustained, sudden offset).\n\nAt rest (before exercise onset): Heart rate is stable. The time series plot is flat. The tangent line is horizontal.\n\nInterpretation: \\(\\frac{dHR}{dt} \\approx 0\\) bpm/min. The rate of change of heart rate is approximately zero.\n\nImmediately at exercise onset (Phase 1 kinetics): Heart rate begins to rise rapidly. The time series plot shows a steep upward slope. The tangent line is steep and positive.\n\nInterpretation: \\(\\frac{dHR}{dt}\\) is large and positive. The rate of change of heart rate is high and increasing Heart Rate.\n\nDuring steady-state exercise: Heart rate stabilizes at an elevated level. The time series plot becomes relatively flat again. The tangent line is nearly horizontal.\n\nInterpretation: \\(\\frac{dHR}{dt} \\approx 0\\) bpm/min. The rate of change of heart rate is near zero; heart rate is in a relatively stable state.\n\nImmediately at exercise offset (Fast recovery phase): Heart rate begins to drop rapidly. The time series plot shows a steep downward slope. The tangent line is steep and negative.\n\nInterpretation: \\(\\frac{dHR}{dt}\\) is large in magnitude and negative. The rate of change of heart rate is high and decreasing Heart Rate.\n\nDuring later recovery (Slow recovery phase): Heart rate continues to drop but more slowly, approaching the resting baseline. The time series plot still has a downward slope, but it’s less steep. The tangent line is negative but closer to horizontal than in the fast phase.\n\nInterpretation: \\(\\frac{dHR}{dt}\\) is negative and its magnitude is decreasing towards zero. Heart rate is still decreasing, but the rate of decrease is slowing down.\n\n\nIn this example, the value of \\(\\frac{dHR}{dt}\\) at any point in time directly tells us the speed and direction of heart rate change at that exact moment, reflecting the instantaneous net effect of all the physiological factors (autonomic input, hormones, etc.) acting on the SA node at that time. Understanding the derivative allows us to quantify the kinetics of the response.\nExample 2: Oxygen Consumption (\\(\\dot{V}\\)O\\(_2\\)) On-Kinetics\nDuring the transition from rest to constant-load submaximal exercise, \\(\\dot{V}\\)O\\(_2\\) (often measured in L/min) increases over time from its resting value to a new steady state.\n\nAt rest: \\(\\dot{V}\\)O\\(_2\\) is stable. \\(\\frac{d\\dot{V}\\text{O}_2}{dt} \\approx 0\\).\nImmediately at exercise onset: Metabolic demand suddenly increases, and oxygen uptake by the muscles begins to rise rapidly. \\(\\frac{d\\dot{V}\\text{O}_2}{dt}\\) becomes large and positive. This reflects the rate at which the body’s oxygen utilization is accelerating.\nAs exercise continues: The rate of increase in \\(\\dot{V}\\)O\\(_2\\) slows down as it approaches the required level for the workload. \\(\\frac{d\\dot{V}\\text{O}_2}{dt}\\) is still positive but its magnitude is decreasing. The slope of the \\(\\dot{V}\\)O\\(_2\\) vs. time curve is decreasing.\nAt steady state: \\(\\dot{V}\\)O\\(_2\\) matches the demand. \\(\\frac{d\\dot{V}\\text{O}_2}{dt} \\approx 0\\).\n\nThe derivative \\(\\frac{d\\dot{V}\\text{O}_2}{dt}\\) captures the speed and profile of the \\(\\dot{V}\\)O\\(_2\\) on-kinetics, which can be affected by training status or oxygen delivery limitations. A faster on-kinetics means \\(\\frac{d\\dot{V}\\text{O}_2}{dt}\\) is larger earlier in the transition.\nExample 3: Blood Lactate Concentration\nDuring incremental exercise, blood lactate concentration ([Lactate]) often remains relatively stable at lower intensities, then begins to rise above a certain threshold.\n\nBelow lactate threshold: Lactate production and clearance are balanced, or clearance slightly exceeds production. \\(\\frac{d[Lactate]}{dt} \\approx 0\\) or slightly negative.\nAbove lactate threshold (accumulating phase): Lactate production exceeds clearance, and blood lactate concentration increases. \\(\\frac{d[Lactate]}{dt}\\) becomes positive. The magnitude reflects the net rate of lactate accumulation.\nSevere exercise: The rate of accumulation can accelerate. \\(\\frac{d[Lactate]}{dt}\\) might become larger.\n\nThe derivative \\(\\frac{d[Lactate]}{dt}\\) tells us the instantaneous net balance between lactate production and clearance.\nExample 4: Substance Flux and Concentration Changes\nConsider a compartment (like muscle interstitial fluid) and a substance (like glucose) moving into it from another compartment (blood) and being consumed within it. The rate of change of glucose concentration in the interstitial fluid (\\(d[Glucose]_{isf}/dt\\)) depends on the rate of glucose entry from blood minus the rate of glucose uptake by muscle cells.\n\\[\n\\frac{d[Glucose]_{isf}}{dt} = \\text{Rate of Entry from Blood} - \\text{Rate of Muscle Uptake}\n\\]\nHere, \\(d[Glucose]_{isf}/dt\\) is the derivative. If the rate of entry from blood is greater than the rate of muscle uptake, the derivative is positive, and interstitial glucose concentration increases. If uptake is greater than entry, the derivative is negative, and concentration decreases. If they are equal, the derivative is zero, and concentration is momentarily stable. The values of “Rate of Entry” and “Rate of Muscle Uptake” themselves often depend on the current concentrations of glucose (in blood and ISF), insulin levels, and muscle activity, making the derivative a function of the system’s state.\n\n\n3.2.3 The Derivative as Slope and Sensitivity\nBeyond just speed and direction, the derivative also represents sensitivity in a dynamic context. If \\(X\\) depends on \\(t\\), \\(\\frac{dX}{dt}\\) can be thought of as how sensitive \\(X\\) is to changes in \\(t\\) at a given moment. In physiological models with multiple interacting variables, we often encounter derivatives with respect to variables other than time. For example, \\(\\frac{d(HR)}{d(Vagal Tone)}\\) (the derivative of Heart Rate with respect to Vagal Tone) would represent the instantaneous sensitivity of Heart Rate to changes in vagal input. While our focus is on derivatives with respect to time (\\(\\frac{dX}{dt}\\)) for dynamic modeling, understanding the derivative as a measure of instantaneous sensitivity is a broader concept in physiological control systems.\n\n\n3.2.4 Connecting Derivatives to Differential Equations\nThe power of understanding the derivative as the instantaneous rate of change is that it is the fundamental component of a differential equation. As we saw briefly in Chapter 1 and in the previous section, a differential equation is an equation that defines or calculates the derivative(s) of your variable(s) based on the current state of the system.\nFor example, the differential equation for simple exponential decay, \\(\\frac{dC}{dt} = -kC\\), is a rule that tells you exactly how to calculate the instantaneous rate of change of concentration (\\(dC/dt\\)) at any moment, given the current concentration (\\(C\\)) and the parameter (\\(k\\)). The derivative is on one side of the equation, and an expression involving the variable(s) and parameters is on the other side.\nWhen we build physiological models using differential equations, we are essentially writing down these rules for how the rates of change of our physiological variables are determined by their current values and the influences acting upon them.\nThe derivative, \\(\\frac{dX}{dt}\\), is the mathematical term for the instantaneous rate of change of a variable \\(X\\) with respect to time \\(t\\). It is a crucial concept in dynamic physiology, quantifying the speed and direction of processes at a specific moment. Understanding its meaning as the slope of a time series curve, and interpreting its sign and magnitude in physiological terms (rapid increase, slow decrease, steady state, net flux, sensitivity), is essential for building and interpreting differential equation models. These models are, at their core, equations that specify exactly how these derivatives are calculated based on the current state of the physiological system. With this intuitive grasp of the derivative, we are ready to explore how physiological processes are described using these fundamental building blocks.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Thinking Dynamically: Rates of Change</span>"
    ]
  },
  {
    "objectID": "03-thinking_dynamically_rates_of_change.html#discrete-vs-continuous-time-models",
    "href": "03-thinking_dynamically_rates_of_change.html#discrete-vs-continuous-time-models",
    "title": "3  Thinking Dynamically: Rates of Change",
    "section": "3.3 Discrete vs Continuous Time Models",
    "text": "3.3 Discrete vs Continuous Time Models\nWe’ve established that physiological variables change over time, and the derivative \\(\\frac{dX}{dt}\\) quantifies the instantaneous rate of this change – its speed and direction at any given moment. Now, let’s think about how we represent the progression of time itself in a mathematical model. This leads to a distinction between discrete time models and continuous time models. Understanding this difference helps clarify why differential equations are the tool of choice for the dynamic physiological blueprints we will build in this book.\n\n3.3.1 Discrete Time Models\nIn discrete time models, we view time as progressing in distinct, separate steps. We calculate the state of the system (the values of our physiological variables) only at specific, predetermined time points, such as at minute 1, minute 2, minute 3, and so on, or perhaps day 1, day 2, day 3, etc. Change happens between these time points, and the model describes how to get from the state at one time point to the state at the next time point.\nThe mathematical tools typically used for discrete time models are difference equations. A difference equation relates the value of a variable at the next time step to its value at the current time step.\nLet’s say \\(X_t\\) is the value of a variable \\(X\\) at time \\(t\\), and \\(X_{t+1}\\) is its value at the next time step (\\(t+1\\)). A simple difference equation might look like:\n\\[X_{t+1} = X_t + \\text{Change calculated over the interval from } t \\text{ to } t+1\\]\nA classic example is simple population growth calculated year by year. If a population grows by a fixed percentage \\(r\\) each year, the population size next year (\\(N_{t+1}\\)) is equal to the population size this year (\\(N_t\\)) plus the growth that occurred this year (\\(r \\times N_t\\)):\n\\[N_{t+1} = N_t + r N_t\\]\nThis can be rewritten as:\n\\[N_{t+1} = (1 + r) N_t\\]\nThis is a difference equation. Given the population size at time \\(t\\), it tells you exactly how to calculate the population size at time \\(t+1\\). You can then use the result for \\(N_{t+1}\\) to calculate \\(N_{t+2}\\), and so on, stepping through time in discrete units (years in this case).\nIn physiology, you might implicitly think in discrete terms when you record data at fixed intervals (e.g., taking a blood pressure reading every 5 minutes). A model that uses these specific, separated time points directly to predict the next reading based on the current one would be a discrete time model. Some biological processes that occur in distinct steps (like cell division cycles or perhaps the timing of certain hormonal pulses if viewed very simply) could potentially be modeled discretely.\n\n\n3.3.2 Continuous Time Models\nIn continuous time models, time is treated as flowing smoothly and continuously, like the sweep of a clock’s second hand. Variables can change at any instant, not just at fixed steps. The model describes the state of the system at any point in time \\(t\\).\nThe mathematical tools used for continuous time models are differential equations. As we’ve seen, a differential equation relates the instantaneous rate of change of a variable (\\(\\frac{dX}{dt}\\)) at time \\(t\\) to the state of the system at that same time \\(t\\).\nLet’s revisit the simple exponential decay model for drug clearance:\n\\[\n\\frac{dC}{dt} = -kC\n\\]\nThis is a differential equation. It doesn’t tell us the concentration at the “next” time step. Instead, it tells us the rate at which the concentration \\(C\\) is changing right now, at time \\(t\\), based on the concentration \\(C\\) at that exact same time \\(t\\). This rule holds true for all points in time, not just discrete intervals. The process of “solving” this differential equation (which we do numerically with tools like R) is equivalent to figuring out the continuous path \\(C(t)\\) that follows this rate rule over time, given a starting concentration.\nMany fundamental physiological processes occur continuously:\n\nChemical reactions happen continuously as molecules collide.\nSubstances diffuse continuously down concentration gradients.\nFluids flow continuously.\nMembrane potentials change continuously based on ion channel activity.\nAutonomic nerve activity, while resulting from discrete action potentials, often exerts a continuous modulatory influence on target organs that can be approximated as smooth changes in tone at a systemic level.\n\n\n\n3.3.3 The Relationship: From Discrete to Continuous\nConceptually, you can think of the instantaneous rate of change (\\(\\frac{dX}{dt}\\)) from a continuous model as being derived from the average rate of change (\\(\\frac{\\Delta X}{\\Delta t}\\)) in a discrete model as the time step (\\(\\Delta t\\)) becomes infinitesimally small.\nImagine a discrete time model where you calculate the change in a variable over a step of size \\(\\Delta t\\):\n\\[\n\\Delta X = X(t + \\Delta t) - X(t)\n\\]\nThe average rate is \\(\\frac{\\Delta X}{\\Delta t}\\).\nIf we can write an equation that tells us this change \\(\\Delta X\\) or the rate \\(\\frac{\\Delta X}{\\Delta t}\\) based on the current state \\(X(t)\\) and other variables, we have a discrete model.\nNow, if the process happens continuously and we consider smaller and smaller \\(\\Delta t\\), the rate \\(\\frac{\\Delta X}{\\Delta t}\\) approaches the instantaneous rate \\(\\frac{dX}{dt}\\). If we can write an equation that tells us this instantaneous rate \\(\\frac{dX}{dt}\\) based on the current state \\(X(t)\\) and other variables, we have a continuous model (a differential equation).\nSo, while mathematically distinct, differential equations (continuous) can often be seen as the limit of difference equations (discrete) as the time step goes to zero.\n\n\n3.3.4 Why Continuous Time Models (ODEs) for this Book?\nWhile discrete time models are valuable for certain applications (like modeling populations with non-overlapping generations or systems with pulsed inputs occurring at fixed intervals), this book focuses on continuous time models using ordinary differential equations (ODEs) because:\n\nPhysiological Reality: Many fundamental biological mechanisms operate continuously. Modeling them as such often provides a more direct and realistic representation of the underlying processes (e.g., modeling blood flow as a continuous rate rather than discrete pulses).\nDescribing Rates Directly: ODEs allow us to explicitly write down equations for the instantaneous rates of change, which aligns well with how we think mechanistically in physiology (“the rate of glucose uptake depends on…”).\nMathematical Framework: A rich mathematical framework exists for analyzing differential equations, and powerful, robust numerical solvers (like those in deSolve) are readily available to simulate their behavior.\nAppropriate for Dynamic Variables: Variables like heart rate, blood pressure, hormone concentrations, and gas volumes change smoothly over time during many physiological challenges (like exercise). Continuous models are well-suited to capture these smooth, dynamic trajectories.\nModeling Regulation and Control: Many physiological regulatory mechanisms (like the baroreflex or autonomic control) involve continuous sensing and adjustment of rates of change, which are naturally represented by differential equations.\n\nWhile we collect data at discrete time points due to measurement limitations, the underlying physiological processes are often best conceptualized and modeled as continuous. Our continuous ODE models will predict the values of variables across continuous time, and we will then “sample” this continuous prediction at the same discrete time points as our experimental data for comparison.\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nThink about the control of breathing. Airflow (volume/time) is a continuous rate. Alveolar gas concentrations change continuously due to this flow and metabolic exchange rates. Chemoreceptors continuously sense partial pressures and send signals that influence the rate and depth of breathing. Modeling this as a continuous system feels more natural than a step-by-step discrete model.\n\n\nIn summary, mathematical models can represent time as either discrete (progressing in steps, using difference equations) or continuous (flowing smoothly, using differential equations). While discrete models are useful for certain biological problems, continuous time models using ODEs are particularly well-suited for describing the dynamic physiological processes that change smoothly over time, based on instantaneous rates that depend on the system’s current state. This book will focus on building these continuous time models using ODEs and leveraging R to simulate their behavior. With our understanding of rates of change, derivatives, and the distinction between discrete and continuous time, we are now ready to begin translating physiological concepts into the language of differential equations.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Thinking Dynamically: Rates of Change</span>"
    ]
  },
  {
    "objectID": "03-thinking_dynamically_rates_of_change.html#moving-from-difference-equations-to-differential-equations",
    "href": "03-thinking_dynamically_rates_of_change.html#moving-from-difference-equations-to-differential-equations",
    "title": "3  Thinking Dynamically: Rates of Change",
    "section": "3.4 Moving From Difference Equations to Differential Equations",
    "text": "3.4 Moving From Difference Equations to Differential Equations\nSo far we’ve explored the idea that physiology is dynamic, that we can quantify change using rates, and that the instantaneous rate of change (the derivative, \\(\\frac{dX}{dt}\\)) is a key concept. We also distinguished between discrete time models (using difference equations to step through time) and continuous time models (using differential equations to describe change at any instant).\nNow, let’s bring these ideas together and see how differential equations naturally arise from considering what happens to a difference equation when we imagine the time steps becoming infinitesimally small. This transition is the conceptual bridge from discrete changes measured over intervals to the continuous dynamics described by ODEs.\n\n3.4.1 Revisiting the Difference Equation Perspective\nRemember that a difference equation describes how a variable changes from one discrete time step to the next. If \\(X_t\\) is the value of a variable at time \\(t\\), and we consider a fixed time step \\(\\Delta t\\), the value at the next step is \\(X_{t+\\Delta t}\\). A difference equation fundamentally states:\n\\[\nX_{t+\\Delta t} = X_t + \\text{Change in X over the interval } \\Delta t\n\\]\nWe can rearrange this equation to focus on the average rate of change over that interval:\n\\[\n\\frac{X_{t+\\Delta t} - X_t}{\\Delta t} = \\frac{\\text{Change in X over the interval } \\Delta t}{\\Delta t}\n\\]\nThe left side is precisely our definition of the average rate of change of \\(X\\) over the interval \\([t, t+\\Delta t]\\).\nNow, let’s think about how we might describe the “Change in X over the interval \\(\\Delta t\\)” in a physiological context. Often, this change is related to the state of the system at the beginning of the interval, \\(X_t\\), and potentially other variables and parameters.\nConsider a compartment filling with a substance. Let \\(X\\) be the amount of substance in the compartment. Suppose the rate at which the substance enters is constant, let’s call this rate \\(R_{in}\\). Over a time interval \\(\\Delta t\\), the amount of substance entering the compartment is \\(R_{in} \\times \\Delta t\\). A simple difference equation for the amount \\(X\\) would be:\n\\[\nX_{t+\\Delta t} = X_t + R_{in} \\times \\Delta t\n\\]\nRearranging to the average rate form:\n\\[\n\\frac{X_{t+\\Delta t} - X_t}{\\Delta t} = R_{in}\n\\]\nThis is a difference equation stating that the average rate of change of \\(X\\) over the interval \\(\\Delta t\\) is equal to the constant inflow rate \\(R_{in}\\).\n\n\n3.4.2 Introducing State Dependence\nThat was a very simple case where the rate of change is constant. More realistically in physiology, the rate at which something changes often depends on the current value of the variable itself or other variables in the system.\nLet’s use a slightly more complex example: a substance being cleared from a compartment, where the rate of clearance is proportional to the amount of substance currently present (like our drug clearance example). Let \\(X\\) be the amount of substance. The rate of clearance at any time \\(t\\) is proportional to \\(X_t\\), let’s say \\(k X_t\\). The change in \\(X\\) over a small time interval \\(\\Delta t\\) due to clearance would be approximately \\(-(k X_t) \\times \\Delta t\\) (negative because \\(X\\) is decreasing).\nA difference equation describing this process over a time step \\(\\Delta t\\) could be:\n\\[\nX_{t+\\Delta t} = X_t - (k X_t) \\times \\Delta t\n\\]\nThis equation says the amount at the next step equals the current amount minus the amount cleared during the interval, calculated based on the amount at the start of the interval and the duration \\(\\Delta t\\).\nAgain, rearrange to the average rate form:\n\\[\n\\frac{X_{t+\\Delta t} - X_t}{\\Delta t} = -k X_t\n\\]\nThis difference equation states that the average rate of change of \\(X\\) over the interval \\(\\Delta t\\) is equal to \\(-k\\) times the value of \\(X\\) at the beginning of the interval.\n\n\n3.4.3 The Limit: \\(\\Delta t \\to 0\\)\nNow, let’s consider what happens to this difference equation, \\(\\frac{X_{t+\\Delta t} - X_t}{\\Delta t} = -k X_t\\), as we make the time step \\(\\Delta t\\) smaller and smaller, approaching zero.\nOn the left side, as \\(\\Delta t\\) approaches zero, the average rate of change over the interval, \\(\\frac{X_{t+\\Delta t} - X_t}{\\Delta t}\\), approaches the instantaneous rate of change at time \\(t\\), which is the derivative \\(\\frac{dX}{dt}\\). This is the fundamental definition of the derivative from calculus. On the right side, the expression \\(-k X_t\\) depends only on the value of \\(X\\) at time \\(t\\) and the constant \\(k\\). As \\(\\Delta t\\) gets smaller, this side of the equation doesn’t change its form; it remains a rule for calculating a rate based on the state at time \\(t\\).\nSo, as we take the limit as \\(\\Delta t \\to 0\\), the difference equation:\n\\[\n\\frac{X_{t+\\Delta t} - X_t}{\\Delta t} = -k X_t\n\\]\ntransforms into the differential equation:\n\\[\n\\frac{dX}{dt} = -k X\n\\]\nThis differential equation states that the instantaneous rate of change of \\(X\\) at time \\(t\\) is equal to \\(-k\\) times the value of \\(X\\) at that exact same time \\(t\\). This equation holds true for all moments in continuous time.\n\n\n3.4.4 Visualizing the Transition\nImagine plotting the results of the difference equation \\(\\frac{X_{t+\\Delta t} - X_t}{\\Delta t} = -k X_t\\) with different values of \\(\\Delta t\\).\n\nIf \\(\\Delta t\\) is large, you’ll get a stair-step graph. The value is calculated at \\(t=0\\), then \\(t=\\Delta t\\), \\(t=2\\Delta t\\), etc., and you might draw lines connecting these points or just show the points. The “rate” applies across the whole large step.\nIf you decrease \\(\\Delta t\\), the steps become smaller. The calculated values at the discrete time points get closer together, and the overall shape of the graph starts to look smoother. The average rate over the tiny steps is a better approximation of the true instantaneous rate.\nAs \\(\\Delta t\\) approaches zero, the stair-step graph becomes an infinitely smooth curve. This smooth curve is the solution to the differential equation \\(\\frac{dX}{dt} = -kX\\).\n\nThis conceptual journey from difference equation to differential equation shows that ODEs are not entirely disconnected from the intuitive idea of calculating change over an interval; they are simply the mathematical formulation that captures what happens when those intervals become infinitely small, allowing us to describe truly continuous processes.\n\n\n3.4.5 Differential Equations: Rules for Instantaneous Rates\nSo, a differential equation like \\(\\frac{dX}{dt} = f(X, \\text{parameters})\\) is fundamentally a statement about the physiological system: it’s a rule that tells you, at any moment in time, how to calculate the speed and direction (\\(\\frac{dX}{dt}\\)) of variable \\(X\\)’s change, based on its current value (\\(X\\)) and any relevant parameters or influences (\\(f(\\dots)\\)).\nIf we have a system of interacting variables, say \\(X\\), \\(Y\\), and \\(Z\\), we would have a system of coupled differential equations, one for each variable:\n\\[\n\\frac{dX}{dt} = f_1(X, Y, Z, \\text{parameters})\n\\]\n\\[\n\\frac{dY}{dt} = f_2(X, Y, Z, \\text{parameters})\n\\]\n\\[\n\\frac{dZ}{dt} = f_3(X, Y, Z, \\text{parameters})\n\\]\nHere, the instantaneous rate of change of \\(X\\) depends on the current values of \\(X\\), \\(Y\\), and \\(Z\\) (and parameters). Similarly for \\(Y\\) and \\(Z\\). These equations capture the dynamic interactions: the rate of change of one variable is influenced by the current state of others.\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nThink about Heart Rate (\\(HR\\)), Sympathetic Tone (\\(S\\)), and Parasympathetic Tone (\\(P\\)).\n\n\\(\\frac{dHR}{dt}\\) depends on \\(S\\) and \\(P\\) at that moment.\n\\(\\frac{dS}{dt}\\) might depend on Blood Pressure (\\(BP\\)) and central command at that moment.\n\\(\\frac{dP}{dt}\\) might also depend on \\(BP\\) and respiration at that moment.\nAnd \\(BP\\) itself changes (\\(\\frac{dBP}{dt}\\)), potentially depending on \\(HR\\), stroke volume, and vascular tone, which in turn depend on \\(S\\) and \\(P\\).\n\nThis interconnected web of dependencies between rates of change and current states is precisely what a system of ODEs describes.\n\n\nTry It Yourself:\nThink about a simple concept like the stretching of a muscle (\\(\\Delta L\\)) over a short time interval (\\(\\Delta t\\)) being approximately proportional to the applied force (\\(F\\)) and the time interval, if we assume some viscoelastic properties.\n\nWrite this as a conceptual difference equation relating \\(L_{t+\\Delta t}\\) to \\(L_t\\), \\(F\\), and \\(\\Delta t\\).\nNow, think about what happens as \\(\\Delta t \\to 0\\). How would you express the instantaneous rate of stretching (\\(dL/dt\\))? How would this relate to the applied force \\(F\\)? You’ve just thought about a differential equation describing the rate of change of muscle length.\n\nThe movement from difference equations to differential equations is conceptual, representing the transition from describing average change over discrete steps to describing instantaneous change in continuous time. Differential equations are the mathematical tool that allows us to define the instantaneous rates of change of physiological variables based on the current state of the system. They provide the ideal framework for building dynamic models that capture the continuous, interacting processes that constitute the “Physiological Blueprint”. With this understanding of rates, derivatives, and their relationship to ODEs, you are now ready to begin the exciting process of translating physiological concepts into these powerful mathematical models.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Thinking Dynamically: Rates of Change</span>"
    ]
  },
  {
    "objectID": "03-thinking_dynamically_rates_of_change.html#exponential-growth-and-decay-in-a-biological-context",
    "href": "03-thinking_dynamically_rates_of_change.html#exponential-growth-and-decay-in-a-biological-context",
    "title": "3  Thinking Dynamically: Rates of Change",
    "section": "3.5 Exponential Growth and Decay in a Biological Context",
    "text": "3.5 Exponential Growth and Decay in a Biological Context\nWe’ve journeyed through the concept of rates of change, understood the derivative \\(\\frac{dX}{dt}\\) as the instantaneous rate, distinguished between discrete and continuous time models, and seen conceptually how differential equations emerge from considering changes over infinitesimally small time steps. Differential equations, we’ve concluded, are the mathematical language that describes how the instantaneous rate of change of a variable is determined by the current state of the system.\nNow, let’s look at some fundamental forms of differential equations that appear frequently in biological and physiological modeling because they capture very basic dynamic rules. These simple forms lead to characteristic patterns of change over time, notably exponential growth and exponential decay (often called first-order kinetics). While real physiological systems are often more complex, understanding these basic dynamic “motifs” is essential, as they serve as building blocks or components within larger, more realistic models.\nThink of these as the simplest dynamic “blueprints” you can draw using the language of ODEs.\n\n3.5.1 Example 1: Simple Exponential Growth (Unchecked)\nWe briefly encountered simple population growth in Chapter 1 as a classic biological model. While not human physiology per se, it represents a fundamental dynamic principle that can appear in physiological contexts, such as the initial rapid proliferation of cells (like cancer cells or cells during wound healing) under ideal, unlimited conditions.\nThe core assumption here is: The rate at which the quantity increases is directly proportional to the current amount of the quantity.\nLet \\(N\\) be the quantity (e.g., number of cells or individuals) at time \\(t\\). The rate of change of \\(N\\) with respect to time is \\(\\frac{dN}{dt}\\). The statement “the rate of increase is proportional to the current amount” translates directly into the differential equation:\n\\[\n\\frac{dN}{dt} = rN\n\\]\nHere:\n\n\\(\\frac{dN}{dt}\\) is the instantaneous rate of change of \\(N\\).\n\\(N\\) is the current amount (number of cells, etc.).\n\\(r\\) is a positive parameter, the growth rate constant. The term \\(rN\\) represents the rate of increase.\nPhysiological/Biological Meaning of the Parameter \\(r\\): This constant \\(r\\) reflects the intrinsic ability of the quantity to increase per unit of amount already present per unit of time. For cells, it’s related to their division rate minus their death rate. A larger \\(r\\) means a faster relative growth rate.\nPredicted Dynamics (\\(N\\) vs. \\(t\\)): If you start with an initial amount \\(N_0 &gt; 0\\) and \\(r &gt; 0\\), this model predicts exponential growth. The rate of increase (\\(rN\\)) is small when \\(N\\) is small, but as \\(N\\) increases, the rate gets faster and faster. When you plot \\(N\\) against \\(t\\), you get a curve that starts shallow but becomes progressively steeper, curving upwards dramatically. This is a positive feedback loop: more quantity leads to a faster rate of increase in that same quantity.\nRate vs. State (\\(dN/dt\\) vs. \\(N\\)): The differential equation itself, \\(\\frac{dN}{dt} = rN\\), is also a statement about the relationship between the rate of change and the current state. If you were to plot \\(\\frac{dN}{dt}\\) on the y-axis against \\(N\\) on the x-axis, this equation describes a straight line passing through the origin with a slope of \\(r\\). The higher \\(N\\) is, the higher the rate of change \\(\\frac{dN}{dt}\\).\nPhysiological Relevance and Limitations: This simple model captures unchecked growth. It’s relevant for initial phases where resources are not limiting. However, in most physiological contexts, growth eventually encounters limitations (space, nutrients, waste accumulation). Modeling these limitations requires more complex ODEs, like the logistic growth model (\\(\\frac{dN}{dt} = rN(1 - N/K)\\)), which includes a carrying capacity \\(K\\), introducing non-linearity and predicting growth that slows down and plateaus. But the basic exponential form is the foundation.\n\n\n\n3.5.2 Example 2: Simple Exponential Decay / First-Order Kinetics\nThis is perhaps one of the most prevalent dynamic patterns in physiological modeling because it describes processes where the rate of decrease is proportional to the amount present.\nThe core assumption is: The rate at which the quantity decreases is directly proportional to the current amount of the quantity.\nLet \\(X\\) be the quantity (e.g., concentration of a drug, amount of a radioactive tracer, level of a signaling molecule) at time \\(t\\). The rate of change of \\(X\\) is \\(\\frac{dX}{dt}\\). Since the quantity is decreasing, the rate of change is negative. The statement “the rate of decrease is proportional to the current amount” translates to:\n\\[\n\\frac{dX}{dt} = -kX\n\\]\nHere:\n\n\\(\\frac{dX}{dt}\\) is the instantaneous rate of change of \\(X\\).\n\\(X\\) is the current amount or concentration.\n\\(k\\) is a positive parameter, the decay rate constant or clearance rate constant. The term \\(kX\\) represents the rate of decrease. The negative sign ensures that when \\(X\\) is positive, \\(\\frac{dX}{dt}\\) is negative, causing \\(X\\) to decrease.\nPhysiological Meaning of the Parameter \\(k\\): This constant \\(k\\) reflects the efficiency or speed of the removal or decay process per unit of amount present. For drug clearance from a well-mixed compartment, \\(k\\) is related to the volume of the compartment and the clearance rate (e.g., by the kidneys or liver). A larger \\(k\\) means a faster relative decay rate. This parameter is directly related to the half-life (\\(T_{1/2}\\)) of the substance, which is the time it takes for the quantity to reduce by half: \\(T_{1/2} = \\frac{\\ln(2)}{k}\\). Measuring the half-life experimentally allows you to estimate the parameter \\(k\\) in your model.\nPredicted Dynamics (\\(X\\) vs. \\(t\\)): If you start with an initial amount \\(X_0 &gt; 0\\) and \\(k &gt; 0\\), this model predicts exponential decay. The rate of decrease (given by \\(-kX\\)) is largest initially when \\(X\\) is highest. As \\(X\\) decreases, the rate of decrease slows down (gets closer to zero). When you plot \\(X\\) against \\(t\\), you get a curve that starts steep and negative but becomes progressively shallower, asymptotically approaching zero over time.\nRate vs. State (\\(dX/dt\\) vs. \\(X\\)): The differential equation \\(\\frac{dX}{dt} = -kX\\) shows a linear relationship between the rate of change and the current state. If you plot \\(\\frac{dX}{dt}\\) on the y-axis against \\(X\\) on the x-axis, this equation describes a straight line passing through the origin with a negative slope of \\(-k\\). The higher \\(X\\) is, the more negative the rate of change \\(\\frac{dX}{dt}\\).\nPhysiological Relevance: This model is fundamental in pharmacokinetics (how drugs move through and are eliminated from the body). It describes first-order elimination, where a constant fraction of the substance is removed per unit time. It also applies to the decay of radioactive isotopes used in tracers, the passive diffusion of substances down a gradient (under certain conditions), and the simple deactivation or degradation of signaling molecules.\n\n\n\n3.5.3 Example 3: First-Order Approach to a Setpoint (Relaxation Dynamics)\nMany physiological variables respond to a sustained stimulus by changing over time to reach a new steady-state value, rather than decaying to zero or growing indefinitely. Think about heart rate or oxygen consumption rising to a plateau during constant-load exercise, or heart rate returning to a resting baseline after exercise cessation. This pattern can often be described by a differential equation where the rate of change is proportional to the difference between the current value and a target or setpoint value.\nThe core assumption here is: The rate of change of the quantity is proportional to the driving force, which is the difference between a target value and the current value.\nLet \\(X\\) be the physiological variable (e.g., \\(\\dot{V}\\)O\\(_2\\) above resting, Heart Rate above resting, a measure of sympathetic tone) at time \\(t\\). Let \\(X_{setpoint}\\) be the target value that \\(X\\) is approaching. The driving force for change is the difference \\((X_{setpoint} - X)\\). The rate of change \\(\\frac{dX}{dt}\\) is proportional to this difference:\n\\[\n\\frac{dX}{dt} = k (X_{setpoint} - X)\n\\]\nHere:\n\n\\(\\frac{dX}{dt}\\) is the instantaneous rate of change of \\(X\\).\n\\(X\\) is the current value of the variable.\n\\(X_{setpoint}\\) is the target value \\(X\\) is approaching (this is a parameter in the model, determined by the stimulus).\n\\(k\\) is a positive parameter, the rate constant determining the speed of the approach.\nPhysiological Meaning of the Parameters \\(k\\) and \\(X_{setpoint}\\): \\(X_{setpoint}\\) represents the new equilibrium level the variable will reach if the conditions remain constant. It’s determined by the magnitude of the sustained stimulus (e.g., the required \\(\\dot{V}\\)O\\(_2\\) for a given power output, the new level of sympathetic tone required to maintain blood pressure during standing). The rate constant \\(k\\) determines how quickly the variable approaches this setpoint. A larger \\(k\\) means a faster response. The time constant (\\(\\tau = 1/k\\)) is often used and represents the time it takes for the variable to complete approximately 63.2% of the total change towards the setpoint. Measuring kinetics in exercise physiology often involves estimating these time constants (e.g., the \\(\\tau\\) for \\(\\dot{V}\\)O\\(_2\\) on-kinetics).\nPredicted Dynamics (\\(X\\) vs. \\(t\\)): This model predicts a first-order exponential approach to the setpoint. If \\(X\\) starts below \\(X_{setpoint}\\), \\((X_{setpoint} - X)\\) is positive, so \\(\\frac{dX}{dt}\\) is positive, and \\(X\\) increases. The rate of increase is largest when \\(X\\) is far below the setpoint and slows down as \\(X\\) gets closer. If \\(X\\) starts above \\(X_{setpoint}\\), \\((X_{setpoint} - X)\\) is negative, so \\(\\frac{dX}{dt}\\) is negative, and \\(X\\) decreases, slowing down as it approaches the setpoint. When you plot \\(X\\) against \\(t\\), you get a curve that smoothly rises or falls and plateaus at \\(X_{setpoint}\\). The shape is an exponential curve shifted and scaled to end at \\(X_{setpoint}\\) instead of zero.\nRate vs. State (\\(dX/dt\\) vs. \\(X\\)): The differential equation \\(\\frac{dX}{dt} = k (X_{setpoint} - X)\\) shows a linear relationship between the rate of change and the current state \\(X\\). If you plot \\(\\frac{dX}{dt}\\) on the y-axis against \\(X\\) on the x-axis, this describes a straight line with a negative slope of \\(-k\\) that crosses the x-axis at \\(X = X_{setpoint}\\) (because when \\(X = X_{setpoint}\\), \\(dX/dt = 0\\)).\nPhysiological Relevance: This is a core model for describing kinetics in exercise physiology (e.g., Phase 2 \\(\\dot{V}\\)O\\(_2\\) kinetics, heart rate kinetics, muscle oxygenation changes) and regulation (e.g., simple models of how a variable returns to a regulated setpoint after a disturbance). It captures the idea that the “drive” for change diminishes as the system gets closer to its target.\nPhysiological Insight: These simple models, while idealized, highlight fundamental principles:\n\nA rate proportional to the quantity itself leads to exponential behavior.\nA positive proportionality leads to growth; a negative proportionality leads to decay.\nA rate proportional to the difference from a setpoint leads to an exponential approach to that setpoint. These patterns are ubiquitous because many biological mechanisms (like diffusion, enzyme kinetics, population dynamics, receptor binding, simple feedback loops) involve rates that depend directly on the amounts or concentration differences currently present.\n\n\nTry It Yourself:\n\nImagine a substance being produced at a constant rate (\\(P_{rate}\\)) and cleared from a compartment via first-order kinetics (\\(\\frac{dX_{cleared}}{dt} = -kX\\)). Write a single differential equation for the rate of change of the amount of substance \\(X\\) in the compartment (\\(\\frac{dX}{dt}\\)). Remember that \\(\\frac{dX}{dt} = \\text{Rate In} - \\text{Rate Out}\\).\nBased on the ODE you wrote in step 1, what do you think happens to \\(X\\) over time if you start with \\(X=0\\)? Do you think it grows indefinitely, decays to zero, or approaches a steady state? Why? What determines the steady-state value? (Hint: At steady state, \\(\\frac{dX}{dt} = 0\\)).\n\nThese examples – exponential growth, exponential decay/first-order kinetics, and first-order approach to a setpoint – demonstrate how simple verbal descriptions of physiological processes translate directly into fundamental forms of differential equations. These ODEs describe the rules by which the instantaneous rate of change of a variable is determined by its current state and system parameters. The parameters in these equations (like \\(r\\), \\(k\\), and \\(X_{setpoint}\\)) have direct physiological interpretations (growth rates, clearance rates, time constants, setpoint values). Understanding these basic ODE forms and the dynamic behaviors they predict (exponential curves) is a crucial step.\nChapter 3 has provided the essential conceptual foundation: dynamic physiology, rates of change, derivatives, the distinction between discrete and continuous models, and the interpretation of simple ODEs. We are now ready to move on to Chapter 4, where we will formalize the components of an ordinary differential equation and begin systematically building simple ODE models from verbal descriptions of physiological processes, preparing us to simulate and visualize these dynamic blueprints using R in Part 2.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Thinking Dynamically: Rates of Change</span>"
    ]
  },
  {
    "objectID": "04-building_simple_differential_equation_models.html",
    "href": "04-building_simple_differential_equation_models.html",
    "title": "4  Building Simple Differential Equation Models",
    "section": "",
    "text": "4.1 Introduction to Ordinary Differential Equations (ODEs)\nHaving spent Chapter 3 delving into the fundamental concept of rates of change and how they relate to continuous time, we are now poised to formally introduce ordinary differential equations (ODEs). As we’ve hinted, ODEs are the mathematical workhorses for building dynamic models of physiological systems. They provide a precise way to express how the instantaneous rates of change of our physiological variables are determined by the current state of the system and any external influences.\nIn essence, an ODE is an equation that involves a function and its derivatives. When we use ODEs to model a physiological system evolving over time, the function we are interested in is the time course of one or more physiological variables (e.g., heart rate as a function of time, \\(HR(t)\\); or glucose concentration as a function of time, \\(C_{glucose}(t)\\)). The ODE then describes how the rate of change of these variables (e.g., \\(\\frac{dHR}{dt}\\), \\(\\frac{dC_{glucose}}{dt}\\)) depends on the current values of the variables themselves, time, and any relevant parameters.\nWhat Makes an ODE “Ordinary”?\nThe term “ordinary” in ODE signifies that the derivatives involved are with respect to a single independent variable, which in the context of dynamic physiological models, is almost always time (\\(t\\)). If a model involved rates of change with respect to more than one independent variable (e.g., both time and spatial position), it would be described by partial differential equations (PDEs), which are beyond the scope of this introductory book. For the physiological systems we’ll be exploring, where we’re primarily interested in how variables change over time within a reasonably well-mixed compartment or the system as a whole, ODEs are the appropriate tool.\nThe General Form of an ODE\nA general form for a single first-order ODE (involving only the first derivative) for a variable \\(x\\) as a function of time \\(t\\) can be written as:\n\\[\\frac{dx}{dt} = f(t, x, p_1, p_2, \\dots)\\]\nLet’s break down this notation:\nComponents of an ODE Model\nFrom the general form above, we can identify the key components that make up an ODE model of a dynamic physiological system:\nOrder of an ODE\nThe order of a differential equation is determined by the highest derivative that appears in it. The equation \\(\\frac{dx}{dt} = f(\\dots)\\) is a first-order ODE because it only involves the first derivative. We will primarily focus on first-order ODEs in this introductory text, as many fundamental physiological processes can be effectively modeled using them. Higher-order ODEs (involving \\(\\frac{d^2x}{dt^2}\\), \\(\\frac{d^3x}{dt^3}\\), etc.) can model more complex dynamics, such as oscillations or inertia-like effects, but their introduction will be more gradual if needed later.\nLinear vs. Nonlinear ODEs\nAnother important distinction is between linear and nonlinear ODEs.\nThe distinction between linear and nonlinear ODEs is significant because linear ODEs often have analytical solutions (mathematical formulas for \\(x(t)\\)), whereas nonlinear ODEs generally do not and must be solved numerically (which is where tools like R’s deSolve package become essential).\nFrom Physiology to ODEs: The Modeling Process\nHow do we go from a physiological understanding of a system to a set of ODEs? This involves several steps:\nThe result of these steps is a system of one or more ODEs that, we hope, captures the essential dynamics of the physiological system we are interested in.\nSimple ODE Examples in Physiology (Revisited and Expanded)\nLet’s revisit the simple examples from Chapter 3, now explicitly framing them as ODEs and highlighting their components:\n1. Simple Exponential Decay (First-Order Clearance)\n2. First-Order Approach to a Setpoint (e.g., Heart Rate Response)\n3. Simple Exponential Growth (e.g., Initial Cell Proliferation)\nA Slightly More Complex Example: A Two-Compartment Model\nTo illustrate a system of ODEs, consider a very simplified model of a hormone (H) being secreted into the bloodstream (Compartment 1) at a constant rate (\\(S\\)) and then eliminated from the bloodstream at a rate proportional to its concentration in the blood. Let \\(H_1(t)\\) be the concentration of the hormone in the bloodstream.\nThe ODE for \\(H_1\\) would be:\n\\[\\frac{dH_1}{dt} = S - k_e H_1(t)\\]\nHere, the rate of change of \\(H_1\\) is determined by two processes: a constant positive input (secretion, \\(S\\)) and a negative output proportional to the current concentration (elimination, \\(-k_e H_1\\)). This is a simple example of how multiple processes can be combined in an ODE to describe the net rate of change.\nWe could even add a second compartment, say the interstitial fluid (Compartment 2), with hormone concentration \\(H_2(t)\\), and model the movement of the hormone between the two compartments. If the movement from blood to interstitial fluid is proportional to \\(H_1\\) and the movement back is proportional to \\(H_2\\), we would get a system of two coupled ODEs:\n\\[\\frac{dH_1}{dt} = S - k_e H_1(t) - k_{12} H_1(t) + k_{21} H_2(t)\\]\\[\\frac{dH_2}{dt} = k_{12} H_1(t) - k_{21} H_2(t)\\]\nHere, \\(k_{12}\\) and \\(k_{21}\\) are rate constants for the movement between compartments. Notice how the rate of change of \\(H_1\\) depends on \\(H_2\\), and vice versa, making them a coupled system.\nSolving ODEs: Finding the Time Course\nThe “solution” to an ODE (or a system of ODEs) is the function (or set of functions) that describes how the state variable(s) change over time, \\(x(t)\\) (or \\(H_1(t)\\) and \\(H_2(t)\\) in the two-compartment example), and that satisfies the differential equation(s).\nFor some simple ODEs (like the basic exponential growth and decay), we can find analytical solutions using calculus. For example, the solution to \\(\\frac{dX}{dt} = -kX\\) with initial condition \\(X(0) = X_0\\) is \\(X(t) = X_0 e^{-kt}\\). You can verify this by taking the derivative of \\(X(t)\\) with respect to \\(t\\) and seeing that it equals \\(-kX(t)\\).\nHowever, for many ODEs, especially nonlinear ones or systems of multiple coupled ODEs, finding an analytical solution is difficult or impossible. This is where numerical methods come in. Numerical solvers, like those implemented in R’s deSolve package, approximate the solution by stepping through time in small increments, using the rate of change defined by the ODEs to estimate the value of the state variables at the next time point. We will delve into this more in Part 2.\nThe Importance of Initial Conditions\nTo get a unique solution to an ODE, we need to specify the initial condition(s) – the value(s) of the state variable(s) at the starting time (usually \\(t=0\\)). For a first-order ODE like \\(\\frac{dx}{dt} = f(t, x, \\dots)\\), we typically need one initial condition, \\(x(t_0) = x_0\\). For a system of \\(n\\) first-order ODEs, we would need \\(n\\) initial conditions, one for each state variable. The initial conditions tell the model where to start its dynamic evolution.\nFor our hormone example with two compartments, to simulate the system, we would need initial concentrations for both \\(H_1(0)\\) and \\(H_2(0)\\).\nLooking Ahead\nSo far we’ve laid the groundwork for understanding what ODEs are, their components (state variables, parameters, rate functions), and the distinction between linear and nonlinear ODEs. We’ve also seen some simple physiological examples. In the next section, we will take the next step and focus on how to develop these simple models from verbal descriptions of physiological processes – how to translate our biological intuition into the mathematical language of ODEs. This will set us up to then use R to simulate and explore the behavior of these dynamic models.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Building Simple Differential Equation Models</span>"
    ]
  },
  {
    "objectID": "04-building_simple_differential_equation_models.html#introduction-to-ordinary-differential-equations-odes",
    "href": "04-building_simple_differential_equation_models.html#introduction-to-ordinary-differential-equations-odes",
    "title": "4  Building Simple Differential Equation Models",
    "section": "",
    "text": "\\(\\frac{dx}{dt}\\): This is the first derivative of the variable \\(x\\) with respect to time \\(t\\), representing the instantaneous rate of change of \\(x\\).\n\\(f(\\dots)\\): This represents a function that specifies how this rate of change is calculated. It can depend on:\n\n\\(t\\): Time itself (e.g., if there’s an explicitly time-dependent input to the system).\n\\(x\\): The current value of the variable \\(x\\). Often, the rate of change depends on how much of \\(x\\) is currently present.\n\\(p_1, p_2, \\dots\\): Parameters of the model. These are constants that characterize the system (e.g., rate constants, volumes, sensitivities).\n\n\n\n\n\nState Variables: These are the physiological quantities that change over time and whose dynamics we are trying to model (e.g., heart rate, blood glucose concentration, muscle force). In our notation above, \\(x\\) is the state variable. A model can have one or more state variables. If there are multiple, we get a system of coupled ODEs.\nParameters: These are constant values that describe inherent properties of the physiological system being modeled (e.g., a rate constant for glucose uptake by cells, the total blood volume, the sensitivity of the baroreceptor reflex). These parameters influence the rates of change of the state variables. In our notation, \\(p_1, p_2, \\dots\\) are the parameters.\nThe Rate Function (f): This is the mathematical expression that defines how the instantaneous rate of change of each state variable depends on the current values of the state variables, time (if applicable), and the parameters. This function embodies our understanding of the physiological mechanisms driving the changes. For each state variable in the model, there will be a corresponding rate function (an ODE).\n\n\n\n\n\n\nAn ODE is linear if the function \\(f\\) is a linear combination of the state variable(s) and any time-dependent terms. For a single variable \\(x\\), a linear first-order ODE would generally look like \\(\\frac{dx}{dt} = a(t)x + b(t)\\), where \\(a(t)\\) and \\(b(t)\\) are functions of time (or constants). The exponential growth and decay models we saw in Chapter 3 (\\(\\frac{dN}{dt} = rN\\) and \\(\\frac{dX}{dt} = -kX\\)) are examples of linear ODEs.\nAn ODE is nonlinear if the function \\(f\\) involves the state variable(s) in a nonlinear way (e.g., \\(x^2\\), \\(\\sin(x)\\), \\(x \\cdot y\\) if \\(y\\) is another state variable). Many biologically interesting models are nonlinear, as they often involve saturations, thresholds, or interactions between variables that are not simply additive. The logistic growth model mentioned earlier is a nonlinear ODE due to the \\(N^2\\) term when expanded.\n\n\n\n\n\nIdentify the State Variables: What are the key quantities that change over time and are crucial for describing the system’s behavior? For example, if we’re modeling glucose regulation, key state variables might include blood glucose concentration and insulin concentration. For a simple model of heart rate response to exercise, the state variable might just be heart rate itself (or perhaps heart rate above resting).\nDetermine the Factors Influencing the Rate of Change: For each state variable, what physiological processes cause it to increase or decrease? Think about fluxes, conversions, regulations. For blood glucose, the rate of change is influenced by glucose entry (from the gut, liver), glucose uptake by tissues, and insulin’s effects on these processes. For heart rate, the rate of change is influenced by autonomic nervous system activity (sympathetic and parasympathetic input).\nFormulate the Rate Functions: Express these influences mathematically as functions of the state variables, parameters, and possibly time. This is where our physiological knowledge translates into mathematical equations. For example, we might say that the rate of glucose uptake by muscle is proportional to the blood glucose concentration and modulated by insulin levels. This would become part of the rate function for blood glucose.\nDefine the Parameters: Identify the constant values that characterize the system, such as rate constants, volumes of compartments, sensitivities of responses, etc. These often need to be estimated from experimental data or taken from the literature.\n\n\n\n\n\n\nState Variable: Concentration of a drug, \\(C(t)\\).\nParameters: Clearance rate constant, \\(k &gt; 0\\).\nRate Function: \\(\\frac{dC}{dt} = -kC(t)\\)\nThis ODE states that the rate of change of the drug concentration is directly proportional to the current concentration, with a negative sign indicating decay. The parameter \\(k\\) dictates how quickly the decay occurs.\n\n\n\nState Variable: Heart rate, \\(HR(t)\\).\nParameters: Target heart rate (setpoint), \\(HR_{target}\\); rate constant, \\(k &gt; 0\\).\nRate Function: \\(\\frac{dHR}{dt} = k (HR_{target} - HR(t))\\)\nThis ODE describes how heart rate changes over time to approach a target value. If \\(HR(t)\\) is below \\(HR_{target}\\), the rate of change is positive (HR increases); if above, it’s negative (HR decreases). The rate of change is proportional to the difference between the current HR and the target HR, with \\(k\\) determining the speed of this adjustment.\n\n\n\nState Variable: Number of cells, \\(N(t)\\).\nParameters: Growth rate constant, \\(r &gt; 0\\).\nRate Function: \\(\\frac{dN}{dt} = rN(t)\\)\nThis ODE models unchecked growth where the rate of increase in cell number is proportional to the current number of cells.\n\n\n\n\nState Variable 1: Hormone concentration in blood, \\(H_1(t)\\).\nParameters: Secretion rate, \\(S\\); elimination rate constant, \\(k_e\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nMany physiological processes involve multiple interacting compartments or variables. For instance, modeling glucose-insulin dynamics requires considering the concentrations of both glucose and insulin, and how they influence each other’s rates of change. These interactions are naturally captured by systems of coupled ODEs.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Building Simple Differential Equation Models</span>"
    ]
  },
  {
    "objectID": "04-building_simple_differential_equation_models.html#components-of-an-ode-model-state-variables-parameters-and-the-rate-function",
    "href": "04-building_simple_differential_equation_models.html#components-of-an-ode-model-state-variables-parameters-and-the-rate-function",
    "title": "4  Building Simple Differential Equation Models",
    "section": "4.2 Components of an ODE Model: State Variables, Parameters, and the Rate Function",
    "text": "4.2 Components of an ODE Model: State Variables, Parameters, and the Rate Function\nIn the previous section, we introduced the concept of ordinary differential equations (ODEs) as the language we’ll use to create our physiological blueprints. We saw that an ODE relates a function (our physiological variable of interest) to its derivatives with respect to a single independent variable, time. Now, let’s dissect the fundamental building blocks that constitute an ODE model: state variables, parameters, and the rate function. Understanding these components is crucial for both interpreting existing models and constructing your own.\n\n4.2.1 State Variables: The Actors in Our Dynamic Story\nState variables are the core of any dynamic model. They represent the quantities within our physiological system that change over time and whose behavior we want to understand or predict. These are the “actors” in the dynamic story our model tells.\n\nWhat they represent: State variables are typically measurable physiological quantities, such as:\n\nConcentration of a substance (e.g., glucose, a hormone, a drug) in a compartment (e.g., blood, interstitial fluid, a cell).\nThe amount or mass of a substance in a compartment.\nPhysiological rates (e.g., heart rate, oxygen consumption).\nPressures (e.g., blood pressure).\nVolumes (e.g., lung volume).\nLevels of activation (e.g., muscle activation, receptor occupancy).\n\nHow they evolve: The ODEs in our model will describe the rates of change of these state variables. By solving these equations (either analytically or numerically), we can determine how the values of these state variables evolve over time, starting from some initial condition. This time evolution is the model’s prediction of the system’s dynamics.\nMultiple State Variables: A model can have one state variable (a single ODE) or multiple state variables (a system of coupled ODEs). Coupled ODEs describe how the rates of change of multiple state variables depend on each other, reflecting the interconnectedness of physiological processes. For instance, a model of glucose-insulin dynamics would likely have at least two state variables: blood glucose concentration and plasma insulin concentration, with their rates of change influencing each other.\nNotation: We typically denote state variables using symbols like \\(x(t)\\), \\(y(t)\\), \\(C(t)\\), \\(HR(t)\\), where the \\((t)\\) emphasizes that their values change with time. If we have multiple state variables, we might use subscripts, e.g., \\(x_1(t)\\), \\(x_2(t)\\), or use different symbols for each (like \\(G(t)\\) for glucose and \\(I(t)\\) for insulin).\n\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nWhen you think about a physiological question you want to model, the first step is often to identify the key measurable quantities that are changing and are central to your question. These will likely become your state variables. For example, if you’re interested in how heart rate responds to exercise, \\(HR(t)\\) is a natural state variable. If you’re modeling drug pharmacokinetics, the drug concentration in the blood or a target tissue would be a state variable.\n\n\n\n\n4.2.2 Parameters: The Fixed Properties of the System\nParameters are the constant values within our ODE model that characterize the inherent properties or constraints of the physiological system we are modeling. Unlike state variables, parameters do not change over time within a single simulation. However, by changing the values of parameters between different simulations, we can explore how these underlying properties affect the system’s dynamic behavior.\n\nWhat they represent: Parameters often correspond to:\n\nRate constants of processes (e.g., the rate of glucose uptake, the rate of hormone degradation).\nPhysical constants (e.g., body temperature, if assumed constant).\nPhysiological properties (e.g., blood volume, sensitivity of a receptor).\nExternal inputs that are held constant during a simulation (e.g., a constant infusion rate of a drug).\nSetpoints or target values in regulatory mechanisms (as seen in the first-order approach example).\n\nInfluence on Dynamics: Parameters dictate the magnitude and speed of the processes described by the rate functions. A change in a parameter’s value can lead to qualitatively or quantitatively different dynamic behaviors of the state variables. For example, a higher clearance rate constant for a drug will result in a faster decay of its concentration. A higher sensitivity of the baroreflex might lead to a more rapid adjustment of heart rate in response to blood pressure changes.\nEstimation: The values of parameters often need to be estimated from experimental data or obtained from the scientific literature. This process of parameter identification or model fitting is a crucial aspect of mathematical modeling in physiology, as the accuracy of the model’s predictions depends on the appropriate choice of parameter values. We will touch upon this in later chapters.\nNotation: Parameters are typically denoted by letters from the middle or end of the alphabet (e.g., \\(k, r, V_{max}, K_m, S\\)). Sometimes, they have subscripts to indicate what they represent (e.g., \\(k_{deg}\\) for a degradation rate constant).\n\n\n\n\n\n\n\nR Tip\n\n\n\nWhen you implement your ODE model in R (which we’ll do using the deSolve package), you’ll usually define the parameters as a named vector. This makes it easy to refer to them within your rate functions.\n\n\nparameters &lt;- c(\n  k_clearance = 0.1, # Clearance rate constant (per minute)\n  HR_target = 120    # Target heart rate (bpm)\n)\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nThink of parameters as the “settings” of your physiological system. They define the inherent rules and capacities. For instance, the strength of the heart muscle, the sensitivity of insulin receptors, or the rate at which enzymes can catalyze reactions are all properties that can be represented by parameters in a model.\n\n\n\n\n4.2.3 The Rate Function: The Rulebook for Change\nThe rate function, often denoted as \\(f\\) in our general ODE form (\\(\\frac{dx}{dt} = f(\\dots)\\)), is the heart of the ODE model. It’s a mathematical expression that specifies how the instantaneous rate of change of a state variable is determined at any given time. This function incorporates the current values of the state variables, the parameters, and possibly time itself to calculate \\(\\frac{dx}{dt}\\).\n\nDescribing Mechanisms: The form of the rate function reflects our understanding of the underlying physiological mechanisms that cause the state variable to increase or decrease. It encodes the rules of interaction within the system. For example:\n\nIf a substance is being produced at a constant rate and degraded at a rate proportional to its concentration, the rate function for the concentration \\(C\\) might look like \\(\\frac{dC}{dt} = P - kC\\), where \\(P\\) is the production rate (a parameter) and \\(k\\) is the degradation rate constant (another parameter).\nIf the rate of change of heart rate depends on the difference between a target heart rate (\\(HR_{target}\\)) and the current heart rate (\\(HR\\)), the rate function might be \\(k(HR_{target} - HR)\\), as we saw earlier.\n\nCombining Influences: The rate function can include multiple terms that represent different processes affecting the state variable. Terms with a positive sign typically indicate processes that increase the state variable, while terms with a negative sign indicate processes that decrease it. The net rate of change is the sum of these individual contributions.\nDependence on State Variables and Parameters: The rate function almost always depends on one or more of the state variables in the model (often the state variable whose rate of change it describes, but also potentially other coupled state variables). It also always depends on one or more of the model’s parameters, which quantify the strength or speed of these influences.\nNonlinearity: The rate function can be linear or nonlinear in terms of the state variables. Nonlinearities often arise from saturable processes, feedback loops, or interactions between multiple state variables. These nonlinearities can lead to complex and interesting dynamic behaviors.\nFor Each State Variable: In a model with multiple state variables, there will be a separate ODE (and thus a separate rate function) for each state variable, describing its rate of change. These rate functions can be coupled, meaning the rate of change of one state variable can depend on the current values of other state variables in the system.\n\n\n\n\n\n\n\nR Tip\n\n\n\nWhen you define your ODE model in R for use with deSolve, you will create a function that takes the current time, the current values of the state variables, and the parameters as input, and returns a list containing the rates of change for each state variable. The rate functions are implemented within this R function.\n\n\n# Example: One state variable (C), one parameter (k)\nmodel_function &lt;- function(t, state, parameters) {\n  C &lt;- state[1] # The state variable\n  k &lt;- parameters[\"k_clearance\"] # A parameter\n\n  dC_dt &lt;- -k * C # The rate function\n\n  return(list(dC_dt)) # Return the rate of change as a list\n}\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nThe rate function is where your understanding of the underlying physiology is most directly encoded. It’s where you translate your knowledge of how different factors (current levels of variables, inherent properties) influence the rate at which a physiological quantity changes. Building a good model often involves carefully thinking about and formulating these rate functions based on known biological mechanisms.\n\n\n\n\n4.2.4 Putting It All Together: A Glucose Disappearance Model\nLet’s consider a very simple model of glucose disappearance from the bloodstream after a bolus injection.\n\nState Variable: Plasma glucose concentration, \\(G(t)\\) (in mmol/L).\nParameter: A first-order disappearance rate constant, \\(k_{glucose}\\) (in \\(min^{-1}\\)).\n\nWe hypothesize that the rate at which glucose disappears from the blood is proportional to the current glucose concentration. This leads to the following ODE:\n\\[\n\\frac{dG}{dt} = -k_{glucose} \\cdot G(t)\n\\]\nHere:\n\n\\(G(t)\\) is our state variable.\n\\(k_{glucose}\\) is our parameter, representing the overall rate of glucose removal per unit concentration.\n\\(-k_{glucose} \\cdot G(t)\\) is the rate function, describing how the rate of change of glucose concentration depends on the current glucose level and the parameter \\(k_{glucose}\\). The negative sign indicates that glucose is disappearing (decreasing).\n\nTo simulate this model, we would also need an initial condition, say the glucose concentration immediately after the bolus injection, \\(G(0) = G_0\\). Solving this ODE (which, as we noted earlier, has an analytical solution \\(G(t) = G_0 e^{-k_{glucose} t}\\)) would give us the predicted time course of glucose concentration in the blood.\nIn this section, we’ve dissected the three fundamental components of an ODE model:\n\nState variables: The dynamic quantities we are tracking.\nParameters: The constant properties that influence the dynamics.\nThe rate function: The mathematical rule that determines how the state variables change over time.\n\nUnderstanding these components is the first crucial step in being able to both interpret and build ODE models of physiological systems. In the next section, we will build upon this knowledge and start to translate verbal descriptions of physiological processes into the language of these ODE models. We’ll see how to take a biological scenario and formulate the state variables, identify relevant parameters, and construct the rate functions that describe their interactions and dynamics. This will pave the way for us to bring these models to life using the power of R in the subsequent parts of this book.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Building Simple Differential Equation Models</span>"
    ]
  },
  {
    "objectID": "04-building_simple_differential_equation_models.html#developing-simple-models-from-verbal-descriptions-of-physiological-processes",
    "href": "04-building_simple_differential_equation_models.html#developing-simple-models-from-verbal-descriptions-of-physiological-processes",
    "title": "4  Building Simple Differential Equation Models",
    "section": "4.3 Developing simple models from verbal descriptions of physiological processes",
    "text": "4.3 Developing simple models from verbal descriptions of physiological processes\nNow that we have a grasp of what ordinary differential equations are and the roles of their key components (state variables, parameters, and the rate function), the next crucial step is to learn how to translate our intuitive understanding of physiological processes, often expressed in words, into the precise language of ODEs. This is where the art and science of mathematical modeling in physiology truly begin.\nThe process typically involves breaking down a physiological phenomenon into its essential components and interactions, identifying what changes over time (our state variables), what influences these changes (leading to our rate functions), and what fixed properties govern the system (our parameters).\nLet’s work through several examples, starting with simple scenarios and gradually increasing complexity, to illustrate this translation process.\n\n4.3.1 Example 1: Simple Substance Diffusion\nImagine a substance moving across a permeable membrane separating two compartments. The rate of movement from compartment 1 to compartment 2 is proportional to the concentration difference between the two compartments.\nModeling Steps:\n\nIdentify State Variables: What are the quantities changing over time? Here, it’s the concentration of the substance in each compartment. Let \\(C_1(t)\\) be the concentration in compartment 1 and \\(C_2(t)\\) be the concentration in compartment 2. These are our two state variables.\nIdentify Parameters: What are the fixed properties influencing this process? The permeability of the membrane will determine the rate of diffusion. Let’s call this permeability constant \\(P\\). We might also need to consider the volumes of the two compartments, \\(V_1\\) and \\(V_2\\), if we want to track the amount of substance rather than concentration, or if the volumes influence the concentration changes. For simplicity, let’s assume fixed volumes and focus on concentration.\nFormulate the Rate Functions: Now, let’s translate the verbal description into mathematical equations for the rates of change of our state variables.\n\nThe rate of movement from compartment 1 to 2 is proportional to \\((C_1 - C_2)\\). Let the rate of change of amount in compartment 2 due to this movement be \\(P \\cdot (C_1 - C_2)\\). To get the rate of change of concentration in compartment 2, we need to divide by the volume \\(V_2\\):\n\\[\n  \\frac{dC_2}{dt} = \\frac{P}{V_2} (C_1 - C_2)\n  \\]\nThis term represents an increase in \\(C_2\\).\nSimilarly, the movement from 1 to 2 causes a decrease in the amount in compartment 1. Dividing by \\(V_1\\) to get the rate of change of concentration in compartment 1:\n\\[\n  \\frac{dC_1}{dt} = -\\frac{P}{V_1} (C_1 - C_2)\n  \\]\nThe negative sign indicates a decrease in \\(C_1\\) due to diffusion to compartment 2.\n\nOur simple model of diffusion between two compartments is then a system of two coupled ODEs:\n\\[\n\\frac{dC_1}{dt} = -\\frac{P}{V_1} (C_1 - C_2)\\]\\[\\frac{dC_2}{dt} = \\frac{P}{V_2} (C_1 - C_2)\n\\]\nHere, the rate of change of concentration in each compartment depends on the concentrations in both compartments and the parameters \\(P\\), \\(V_1\\), and \\(V_2\\).\n\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nThis simple model captures the fundamental principle of passive transport driven by concentration gradients, a crucial process in many physiological systems (e.g., gas exchange in the lungs, nutrient exchange across capillaries).\n\n\n\n\n4.3.2 Example 2: A Hormone Secretion and Degradation Model (Revisited)\nA hormone is secreted into the bloodstream at a constant rate. It is also degraded in the bloodstream at a rate proportional to its current concentration.\nModeling Steps:\n\nIdentify State Variables: The concentration of the hormone in the bloodstream, \\(H(t)\\). (One state variable in this case).\nIdentify Parameters:\n\nSecretion rate, \\(S\\) (e.g., in concentration units per time).\nDegradation rate constant, \\(k_{deg}\\) (per time).\n\nFormulate the Rate Function: The rate of change of hormone concentration is the balance between secretion (which increases concentration) and degradation (which decreases it).\n\nRate of increase due to secretion: \\(S\\) (constant).\nRate of decrease due to degradation: \\(k_{deg} \\cdot H(t)\\) (proportional to concentration).\n\nCombining these gives us the ODE:\n\\[\n\\frac{dH}{dt} = S - k_{deg} H(t)\n\\]\nThis single first-order ODE describes the dynamics of the hormone concentration.\n\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nMany hormones and signaling molecules have their levels regulated by a balance between production/release and degradation/clearance. This simple model captures this fundamental regulatory motif.\n\n\n\n\n4.3.3 Example 3: A Simple Model of Muscle Fatigue\nDuring sustained muscle activity, a fatigue factor builds up. The rate of buildup of this fatigue factor is proportional to the level of muscle activity. The muscle’s force-generating capacity decreases linearly with the level of the fatigue factor. When activity ceases, the fatigue factor decays exponentially back to zero.\nModeling Steps:\n\nIdentify State Variables: We need a variable to represent the fatigue factor, let’s call it \\(F(t)\\), and perhaps a measure of muscle activity, \\(A(t)\\). Let’s assume \\(A(t)\\) is an input to our model (we prescribe it, e.g., it’s high during exercise and zero at rest), and \\(F(t)\\) is our state variable that changes over time. We might also consider muscle force as a state variable, but the description suggests it’s directly related to \\(F(t)\\). So, let’s focus on \\(F(t)\\) as the primary dynamic state.\nIdentify Parameters:\n\nRate constant for fatigue buildup per unit activity, \\(k_{buildup}\\).\nRate constant for fatigue decay, \\(k_{decay}\\).\nA parameter relating fatigue to force reduction, say \\(\\alpha\\) (so force \\(\\propto 1 - \\alpha F\\)).\n\nFormulate the Rate Function for Fatigue (\\(F(t)\\)):\n\nDuring muscle activity (\\(A(t) &gt; 0\\)): The rate of buildup is proportional to \\(A(t)\\): \\[\\frac{dF}{dt} = k_{buildup} \\cdot A(t) - k_{decay} \\cdot F(t)\\] We’ve also included a decay term here, assuming some natural recovery even during activity.\nWhen activity ceases (\\(A(t) = 0\\)): The fatigue factor decays exponentially: \\[\\frac{dF}{dt} = -k_{decay} \\cdot F(t)\\]\n\nThis example shows how the rate function can depend on external inputs (\\(A(t)\\)) and can change depending on the conditions. This might require us to define our model in a way that accounts for these different phases (activity vs. rest).\nWe could also model muscle force (\\(Force(t)\\)) as being related to the fatigue factor:\n\\[\nForce(t) = Force_{max} \\cdot (1 - \\alpha F(t))\n\\]\nHere, \\(Force(t)\\) is not a state variable whose rate of change is directly modeled by an ODE, but rather an output that depends on the state variable \\(F(t)\\).\n\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nThis model, although simple, captures the common experience of fatigue building up during exertion and recovering afterward. More sophisticated models of fatigue might include multiple state variables representing different metabolic factors.\n\n\nGeneral Strategies for Translating Verbal Descriptions to ODEs:\n\nIdentify the “things” that are changing: These will be your state variables.\nDetermine what causes these “things” to increase or decrease: These will inform the terms in your rate functions. Think about rates of flow, production, consumption, conversion, etc.\nIdentify any constant factors that influence these rates: These will be your parameters.\nExpress the relationships mathematically: If a rate is proportional to a quantity \\(X\\), it will involve a term like \\(k \\cdot X\\). If it’s a constant rate, it will be just a parameter. If it depends on the difference between two quantities, it will involve a term like \\(k \\cdot (Y - Z)\\).\n\nDealing with Multiple Processes:\nOften, the rate of change of a state variable is influenced by multiple processes acting simultaneously. In this case, the rate function is the sum of the rates of all these individual processes (with appropriate signs for increases and decreases).\nFor a state variable \\(X\\), if it increases due to process 1 at rate \\(R_1\\) and decreases due to process 2 at rate \\(R_2\\), the ODE would be:\n\\[\n\\frac{dX}{dt} = R_1 - R_2\n\\]\n\n\n4.3.4 Example: Blood Glucose Regulation (Simplified)\nBlood glucose concentration increases due to glucose entering the bloodstream from the gut (at a rate that decreases as glucose levels rise) and decreases due to uptake by tissues (at a rate proportional to glucose concentration).\nModeling Steps:\n\nState Variable: Blood glucose concentration, \\(G(t)\\).\nParameters:\n\nMaximum rate of glucose entry from the gut, \\(V_{in}\\).\nA parameter controlling how glucose entry decreases with \\(G\\), \\(K_{in}\\).\nRate constant for glucose uptake by tissues, \\(k_{out}\\).\n\nRate Function:\n\nRate of glucose entry: Let’s model the decreasing rate with a form like \\(\\frac{V_{in}}{1 + G(t)/K_{in}}\\). This decreases as \\(G(t)\\) increases (a form of saturable input).\nRate of glucose uptake: \\(k_{out} \\cdot G(t)\\) (proportional to glucose).\n\nCombining these, the ODE for blood glucose concentration would be:\n\\[\n\\frac{dG}{dt} = \\frac{V_{in}}{1 + G(t)/K_{in}} - k_{out} G(t)\n\\]\nThis single ODE captures a basic regulatory aspect: as glucose levels rise, the input might slow down, while the output increases.\n\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nEven this simplified model hints at the feedback mechanisms involved in glucose regulation. More complex models would include the role of insulin and other hormones.\n\n\n\n\n4.3.5 The Importance of Assumptions\nIt’s crucial to recognize that any mathematical model is based on a set of simplifying assumptions about the real physiological system. The level of detail we include depends on the specific questions we want to address with the model. Simple models, like the ones we’ve discussed, can be useful for understanding fundamental principles, while more complex models might be needed for detailed quantitative predictions.\nAs we move forward, we will encounter more sophisticated ways of formulating rate functions to represent various physiological phenomena, including nonlinearities, feedback loops, and interactions between multiple state variables. The key is to start with a clear understanding of the verbal description of the process and then systematically translate the components and their interactions into the mathematical language of ODEs.\nIn the next section, we will explore some basic examples of ODE models relevant to exercise physiology and cardiac autonomic modulation, further solidifying this translation process. We will then be well-equipped to start implementing and simulating these models using R in Part 2.\nOkay, let’s craft a significantly longer version of the “Examples” subsection, providing more depth and potentially introducing nuances within the basic models to illustrate the concepts more thoroughly and approach the desired length.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Building Simple Differential Equation Models</span>"
    ]
  },
  {
    "objectID": "04-building_simple_differential_equation_models.html#examples-from-basic-to-complex-models",
    "href": "04-building_simple_differential_equation_models.html#examples-from-basic-to-complex-models",
    "title": "4  Building Simple Differential Equation Models",
    "section": "4.4 Examples: From basic to complex models",
    "text": "4.4 Examples: From basic to complex models\nTo truly grasp the power and flexibility of ODE modeling, it’s essential to see how even seemingly simple physiological scenarios can be translated into mathematical equations. This subsection will delve into two fundamental examples: a model of substance concentration change and a model of muscle fatigue. We will explore variations and expansions of these basic models to highlight how different assumptions about the underlying biology lead to different mathematical formulations and, consequently, different predicted dynamic behaviors.\n\n4.4.1 Example 1: A Comprehensive Exploration of Substance Concentration Change\nLet’s consider a substance within a well-defined physiological compartment, such as a hormone in the bloodstream or a metabolite within a cell. The concentration of this substance, which we denote as \\(C(t)\\), is our state variable. Its dynamics will be governed by processes that add to its concentration (production, influx) and processes that remove it (degradation, efflux).\nScenario 1.1: Simple Production and First-Order Degradation\nThe substance is produced at a constant rate, \\(P\\), and is degraded at a rate proportional to its current concentration, with a rate constant \\(k_{deg}\\).\nODE Model:\n\\[\n\\frac{dC}{dt} = P - k_{deg} \\cdot C(t)\n\\]\nHere, \\(P\\) has units of concentration per time (e.g., mol/(L·min)), and \\(k_{deg}\\) has units of inverse time (e.g., \\(min^{-1}\\)). The term \\(k_{deg} \\cdot C(t)\\) thus represents the rate of concentration decrease due to degradation, with the same units as production.\nAs we discussed earlier, this model leads to an exponential approach to a steady-state concentration \\(C_{ss} = P/k_{deg}\\). The time it takes to reach this steady state is related to \\(1/k_{deg}\\).\nScenario 1.2: Production Dependent on Another Substance\nNow, imagine the production of our substance \\(C\\) is not constant but is stimulated by the concentration of another substance \\(S(t)\\). Let’s assume this stimulation follows a simple linear relationship: the rate of production of \\(C\\) is \\(k_{prod} \\cdot S(t)\\), where \\(k_{prod}\\) is a constant. Substance \\(C\\) still degrades at a first-order rate.\nODE Model:\n\\[\n\\frac{dC}{dt} = k_{prod} \\cdot S(t) - k_{deg} \\cdot C(t)\n\\]\nHere, the dynamics of \\(C(t)\\) now depend on the temporal profile of \\(S(t)\\). If \\(S(t)\\) itself is governed by another ODE, we would have a coupled system. For instance, if \\(S(t)\\) increases linearly with time (\\(S(t) = \\alpha t\\)), then the rate of production of \\(C\\) would also increase linearly.\nScenario 1.3: Saturable Degradation\nInstead of a degradation rate strictly proportional to concentration, many biological processes exhibit saturation. At high concentrations, the degradation machinery might become overwhelmed, and the rate of degradation plateaus. We can model this using Michaelis-Menten kinetics.\nODE Model:\n\\[\n\\frac{dC}{dt} = P - \\frac{V_{max} \\cdot C(t)}{K_m + C(t)}\n\\]\nHere, \\(P\\) is the constant production rate, \\(V_{max}\\) is the maximum degradation rate (in concentration per time), and \\(K_m\\) is the Michaelis constant (in concentration), representing the concentration at which the degradation rate is half of \\(V_{max}\\). This model is nonlinear, which can lead to more complex dynamic behaviors, including non-exponential approaches to steady state and the possibility of multiple steady states under certain conditions (though not in this simple form with constant production).\nScenario 1.4: Influx and Efflux Across a Membrane\nConsider the concentration of a substance inside a cell. It can enter the cell from the extracellular space at a rate proportional to the extracellular concentration (\\(C_{out}\\), assumed constant) and leave the cell at a rate proportional to its intracellular concentration (\\(C_{in} = C(t)\\)).\nODE Model:\n\\[\n\\frac{dC_{in}}{dt} = k_{in} \\cdot C_{out} - k_{out} \\cdot C_{in}(t)\n\\]\nHere, \\(k_{in}\\) and \\(k_{out}\\) are permeability coefficients (with units of inverse time if \\(C_{out}\\) and \\(C_{in}\\) are concentrations, leading to rates of change in concentration per time). This model again has the form of a first-order linear ODE, leading to an exponential approach to a steady state where the rates of influx and efflux are equal.\n\n\n4.4.2 Example 2: A Multifaceted Model of Muscle Fatigue\nMuscle fatigue is a complex phenomenon with contributions from various factors, including metabolite accumulation, energy depletion, and neural signaling. Let’s build a simple ODE model focusing on a key aspect: the accumulation and recovery of a fatigue-inducing metabolite.\nScenario 2.1: Basic Accumulation and Linear Clearance\nDuring muscle activity at a constant level \\(A\\), a metabolite \\(M(t)\\) accumulates at a rate proportional to \\(A\\). The metabolite is cleared at a rate proportional to its current concentration.\nODE Model:\n\\[\n\\frac{dM}{dt} = k_{prod} \\cdot A - k_{clear} \\cdot M(t)\n\\]\nWe analyzed this model earlier. It leads to a steady-state metabolite level where production equals clearance.\nScenario 2.2: Activity-Dependent Production and Enhanced Recovery\nLet’s refine this. The rate of metabolite production is indeed proportional to the level of muscle activity \\(A(t)\\), which can now vary over time (e.g., during an exercise bout followed by rest). The clearance of the metabolite is proportional to its concentration, but we hypothesize that during recovery (when \\(A(t) = 0\\)), the clearance mechanism is more efficient.\nODE Model:\nWe can express this piecewise:\nIf \\(A(t) &gt; 0\\) (exercise):\n\\[\n\\frac{dM}{dt} = k_{prod} \\cdot A(t) - k_{clear\\_ex} \\cdot M(t)\n\\]\nIf \\(A(t) = 0\\) (recovery):\n\\[\n\\frac{dM}{dt} = -k_{clear\\_rec} \\cdot M(t)\n\\]\nwhere \\(k_{clear\\_rec} &gt; k_{clear\\_ex}\\).\nThis model allows us to simulate the rise of the metabolite during exercise (possibly with varying intensity \\(A(t)\\)) and its faster decline during the recovery phase.\nScenario 2.3: Threshold Effect on Force Production\nLet’s link the metabolite concentration to muscle force (\\(F\\)). Suppose that force production is negatively affected by the metabolite concentration, but only above a certain threshold (\\(M_{thresh}\\)). Above this threshold, force decreases linearly with increasing metabolite concentration.\nAlgebraic Equation (not an ODE for force, but links to our state variable):\n\\[\nF(t) =\n\\begin{cases}\n  F_{max}                               & \\text{if } M(t) \\leq M_{thresh} \\\\\n  F_{max} - s \\cdot (M(t) - M_{thresh}) & \\text{if } M(t) &gt; M_{thresh}\n\\end{cases}\n\\]\nHere, \\(F_{max}\\) is the maximal force, and \\(s\\) is a sensitivity parameter. By combining this algebraic equation with the ODE for \\(M(t)\\) from Scenario 2.2, we can model how muscle force might change dynamically during exercise and recovery as a consequence of metabolite accumulation.\n\n\n\n\n\n\nPhysiological Insight\n\n\n\nIn reality, muscle fatigue is likely due to the interplay of multiple factors. We could extend our model to include another fatigue-related variable, say \\(E(t)\\) representing energy depletion, which also affects force production and whose dynamics depend on muscle activity and recovery processes. This would lead to a system of coupled ODEs for \\(M(t)\\) and \\(E(t)\\), and then an algebraic equation relating both to force \\(F(t)\\). This moves us towards more complex, multi-state variable models.\n\n\nBy exploring these different scenarios for both substance concentration change and muscle fatigue, you can see how the verbal description of a physiological process directly translates into the components of an ODE model: the state variable(s), the parameters that quantify the rates of change, and the rate function(s) that describe how these changes occur. The complexity of the model depends on the level of detail we want to include about the underlying mechanisms.\nIn the following chapters, we will take these types of simple models and learn how to bring them to life using the computational power of R, allowing us to simulate their behavior and visualize the resulting dynamics. This will provide you with the tools to explore your own hypotheses about physiological systems using the language of ordinary differential equations.",
    "crumbs": [
      "Foundations in Modeling and R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Building Simple Differential Equation Models</span>"
    ]
  }
]